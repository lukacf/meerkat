---
title: "Configuration"
description: "Environment variables, config files, provider setup, and tuning options for Meerkat."
icon: "sliders"
---

Meerkat uses layered configuration: defaults, then config file, then environment variables (secrets only). CLI flags and programmatic settings override everything else.

## Environment variables

Environment variables are used **only for API key secrets**. All other settings go in config files.

| Variable | Fallback | Provider |
|----------|----------|----------|
| `RKAT_ANTHROPIC_API_KEY` | `ANTHROPIC_API_KEY` | Anthropic Claude |
| `RKAT_OPENAI_API_KEY` | `OPENAI_API_KEY` | OpenAI GPT |
| `RKAT_GEMINI_API_KEY` | `GEMINI_API_KEY`, `GOOGLE_API_KEY` | Google Gemini |

<Note>
The `RKAT_*` variants take precedence over provider-native names, so you can run Meerkat with dedicated keys separate from other tools.
</Note>

You only need a key for the provider you plan to use. Set at least one:

```bash
export ANTHROPIC_API_KEY="sk-ant-..."
```

## Config file

Meerkat loads config from TOML files in two locations:

| Location | Scope | Example path |
|----------|-------|--------------|
| `.rkat/config.toml` | Project (checked into repo or gitignored) | `./my-project/.rkat/config.toml` |
| `~/.rkat/config.toml` | Global (user-wide defaults) | `~/.rkat/config.toml` |

**Precedence:** defaults &rarr; global config &rarr; project config &rarr; env vars &rarr; CLI flags.

Project config wins over global config. If neither exists, built-in defaults apply.

### Minimal example

```toml .rkat/config.toml
[agent]
model = "claude-opus-4-6"
max_tokens_per_turn = 16384

[shell]
program = "bash"
timeout_secs = 30
```

### Generating a config file

```bash
rkat config init          # Creates .rkat/config.toml with defaults
rkat config init --global # Creates ~/.rkat/config.toml
```

## Providers

<div id="providers" />

Each provider needs its API key set as an environment variable and a model selected.

<Tabs>
  <Tab title="Anthropic">
    ```bash
    export ANTHROPIC_API_KEY="sk-ant-..."
    ```

    | Model | Context | Max output | Best for |
    |-------|---------|------------|----------|
    | `claude-opus-4-6` | 200K / 1M (beta) | 128K | Complex reasoning, highest quality |
    | `claude-sonnet-4-5` | 200K / 1M (beta) | 64K | Balanced performance and cost |
    | `claude-opus-4-5` | 200K | 64K | Legacy Opus (still supported) |
    | `claude-haiku-4-5` | 200K | 64K | Fast, simple tasks |

    ```toml .rkat/config.toml
    [agent]
    model = "claude-opus-4-6"
    max_tokens_per_turn = 16384
    ```
  </Tab>
  <Tab title="OpenAI">
    ```bash
    export OPENAI_API_KEY="sk-..."
    ```

    | Model | Context | Best for |
    |-------|---------|----------|
    | `gpt-5.2` | 1M | General purpose, advanced reasoning |
    | `gpt-5.2-pro` | 1M | Highest quality reasoning |
    | `gpt-5.1-codex-max` | 1M | Code generation, agentic coding |

    ```toml .rkat/config.toml
    [agent]
    model = "gpt-5.2"
    max_tokens_per_turn = 8192
    ```
  </Tab>
  <Tab title="Gemini">
    ```bash
    export GOOGLE_API_KEY="AIza..."
    ```

    | Model | Context | Best for |
    |-------|---------|----------|
    | `gemini-3-pro-preview` | 1M | Advanced reasoning, complex tasks |
    | `gemini-3-flash-preview` | 1M | Fast, balanced performance |

    ```toml .rkat/config.toml
    [agent]
    model = "gemini-3-pro-preview"
    max_tokens_per_turn = 8192
    ```
  </Tab>
</Tabs>

### SDK feature flags

When using Meerkat as a Rust library, enable only the providers you need:

| Feature | Description | Default |
|---------|-------------|---------|
| `anthropic` | Anthropic Claude support | Yes |
| `openai` | OpenAI GPT support | No |
| `gemini` | Google Gemini support | No |
| `all-providers` | All LLM providers | No |

<CodeGroup>

```toml Anthropic only (smallest binary)
meerkat = { version = "0.1", features = ["anthropic", "jsonl-store"] }
```

```toml All providers
meerkat = { version = "0.1", features = ["all-providers", "jsonl-store"] }
```

```toml Testing (in-memory storage)
meerkat = { version = "0.1", features = ["anthropic", "memory-store"] }
```

</CodeGroup>

## Budget controls

Budget limits cap resource usage per agent run. When a limit is reached the agent completes its current turn, then stops.

<ParamField path="max_tokens" type="integer">
  Total input + output tokens across all turns. When exceeded the agent finishes its current turn and returns partial results.
</ParamField>

<ParamField path="max_duration" type="string">
  Maximum wall-clock runtime. Accepts human-readable durations like `"30s"`, `"5m"`, `"2h"`. When exceeded the agent completes the current turn, then stops.
</ParamField>

<ParamField path="max_tool_calls" type="integer">
  Maximum total tool invocations. When exceeded, further tool calls are rejected and the agent continues without tools.
</ParamField>

### Config file

```toml .rkat/config.toml
[budget]
max_tokens = 50000
max_duration = "5m"
max_tool_calls = 50
```

### CLI flags

```bash
rkat run --max-tokens 50000 --max-duration "5m" --max-tool-calls 50 "Your prompt"
```

### Programmatic (SDK)

```rust
use meerkat::BudgetLimits;
use std::time::Duration;

let result = meerkat::with_anthropic(api_key)
    .model("claude-opus-4-6")
    .with_budget(BudgetLimits {
        max_tokens: Some(50_000),
        max_duration: Some(Duration::from_secs(300)),
        max_tool_calls: Some(50),
    })
    .run("Your prompt")
    .await?;
```

### Retry policy

Failed LLM calls are retried automatically with exponential backoff and jitter.

```toml .rkat/config.toml
[retry]
max_retries = 3
initial_delay_ms = 500
max_delay_ms = 10000
multiplier = 2.0
```

Delay formula: `min(initial_delay * multiplier^attempt, max_delay) * jitter` where jitter is between 0.9 and 1.1.

| Error | Retried? |
|-------|----------|
| `RateLimited` | Yes (uses retry-after header when available) |
| `ServerOverloaded` | Yes |
| `NetworkTimeout` | Yes |
| `ConnectionReset` | Yes |
| `ServerError (5xx)` | Yes |
| `InvalidRequest` | No |
| `AuthenticationFailed` | No |
| `ContentFiltered` | No |
| `ContextLengthExceeded` | No |

## Session persistence

Sessions record conversation history so agents can resume where they left off.

<Tabs>
  <Tab title="JSONL (default)">
    Sessions are stored as JSONL files, one per session. Each file contains the complete session state updated after each turn.

    ```text
    ~/.local/share/meerkat/sessions/
    ├── 01936f8a-7b2c-7000-8000-000000000001.jsonl
    ├── 01936f8a-7b2c-7000-8000-000000000002.jsonl
    └── ...
    ```

    Requires the `jsonl-store` feature flag (enabled by default).

    ```toml .rkat/config.toml
    [store]
    sessions_path = "/custom/path/to/sessions"
    ```

    ```rust
    use meerkat::JsonlStore;
    let store = JsonlStore::new("/custom/path/to/sessions");
    store.init().await?;
    ```
  </Tab>
  <Tab title="redb (embedded database)">
    Durable embedded storage using [redb](https://github.com/cberner/redb). Stores sessions and events in a single database file.

    Requires the `session-store` feature flag.

    ```rust
    use meerkat_store::RedbSessionStore;
    let store = RedbSessionStore::open("/path/to/meerkat.redb")?;
    ```
  </Tab>
  <Tab title="In-memory (testing)">
    Ephemeral storage that lives only in process memory. Useful for tests.

    Requires the `memory-store` feature flag.

    ```rust
    use meerkat::MemoryStore;
    let store = MemoryStore::new();
    ```
  </Tab>
</Tabs>

### Managing sessions

```bash
rkat sessions list [--limit N]
rkat sessions show <SESSION_ID>
```

## Advanced

<Accordion title="Hooks configuration">
  Hooks let you run custom logic at defined points in the agent lifecycle. See the [hooks guide](/hooks) for the full walkthrough.

  ### Config file setup

  ```toml .rkat/config.toml
  [hooks]
  default_timeout_ms = 5000
  payload_max_bytes = 131072
  background_max_concurrency = 32

  [[hooks.entries]]
  id = "pre_tool_guard"
  enabled = true
  point = "pre_tool_execution"
  mode = "foreground"
  capability = "guardrail"
  priority = 10
  failure_policy = "fail_closed"
  timeout_ms = 800

  [hooks.entries.runtime]
  type = "in_process"
  name = "pre_tool_guard"
  ```

  ### Hook points

  | Point | Description |
  |-------|-------------|
  | `run_started` | Fires when a run begins |
  | `run_completed` | Fires when a run completes successfully |
  | `run_failed` | Fires when a run fails |
  | `pre_llm_request` | Before each LLM API call |
  | `post_llm_response` | After each LLM API response |
  | `pre_tool_execution` | Before a tool is executed |
  | `post_tool_execution` | After a tool is executed |
  | `turn_boundary` | At the boundary between turns |

  ### Runtimes

  | Runtime | Description |
  |---------|-------------|
  | `in_process` | Runs in the agent process |
  | `command` | Runs as an external command |
  | `http` | Calls an HTTP endpoint |

  <Warning>
  `command` and `http` hooks are treated as trusted code for the project where they are configured. Do not run hook-enabled projects from untrusted sources without reviewing `.rkat/config.toml`.
  </Warning>

  ### Layering and precedence

  Hook entries are merged in a deterministic order:

  <Steps>
    <Step title="Global config">
      Hooks from `~/.rkat/config.toml` are loaded first.
    </Step>
    <Step title="Project config">
      Hooks from `.rkat/config.toml` are merged next.
    </Step>
    <Step title="Run overrides">
      Per-run override entries are applied last.
    </Step>
  </Steps>

  Run overrides can also disable configured hooks by id.

  ### Run override JSON schema

  All control surfaces accept `HookRunOverrides`:

  ```json
  {
    "disable": ["global_observer"],
    "entries": [
      {
        "id": "run_pre_tool_rewrite",
        "enabled": true,
        "point": "pre_tool_execution",
        "mode": "foreground",
        "capability": "rewrite",
        "priority": 10,
        "runtime": {
          "type": "in_process",
          "name": "run_pre_tool_rewrite"
        }
      }
    ]
  }
  ```

  This same payload is used by:
  - **CLI:** `--hooks-override-json` / `--hooks-override-file`
  - **REST:** `CreateSessionRequest.hooks_override` / `ContinueSessionRequest.hooks_override`
  - **MCP server:** `MeerkatRunInput.hooks_override` / `MeerkatResumeInput.hooks_override`
</Accordion>

<Accordion title="Memory and compaction">
  See the [memory guide](/memory) for a full walkthrough.

  ### Semantic memory

  When the `memory-store-session` feature is enabled and memory is activated (`enable_memory` on `AgentFactory` or `override_memory` on `AgentBuildConfig`), the agent gains a `memory_search` tool backed by `HnswMemoryStore` (hnsw_rs + redb). Compacted conversation turns are automatically indexed for later recall.

  Memory data is stored under `<store_path>/memory/`.

  ### Compaction config

  Compaction summarizes older conversation turns to keep context windows manageable. Controlled by `CompactionConfig`:

  | Parameter | Default | Description |
  |-----------|---------|-------------|
  | `auto_compact_threshold` | `100000` | Trigger when `last_input_tokens` reaches this value |
  | `recent_turn_budget` | `4` | Number of recent complete turns to retain verbatim |
  | `max_summary_tokens` | `4096` | Max tokens for the compaction summary |
  | `min_turns_between_compactions` | `3` | Minimum turns between consecutive compactions |

  <Note>
  Compaction requires the `session-compaction` feature flag. When disabled, `SessionService` returns `SessionError::CompactionDisabled`.
  </Note>
</Accordion>

<Accordion title="Sub-agent configuration">
  See the [sub-agents guide](/sub-agents) for full details.

  Sub-agent policy is configured under `[sub_agents]`:

  ```toml .rkat/config.toml
  [sub_agents]
  default_provider = "inherit"   # "inherit" = use parent's provider
  default_model = "inherit"      # "inherit" = use parent's model

  [sub_agents.allowed_models]
  anthropic = ["claude-opus-4-6", "claude-sonnet-4-5"]
  openai = ["gpt-5.2"]
  gemini = ["gemini-3-flash-preview", "gemini-3-pro-preview"]
  ```

  ### Concurrency limits

  | Parameter | Default | Description |
  |-----------|---------|-------------|
  | `max_depth` | `3` | Maximum sub-agent nesting depth |
  | `max_concurrent_ops` | `32` | Maximum concurrent operations (all types) |
  | `max_concurrent_agents` | `8` | Maximum concurrent sub-agents |
  | `max_children_per_agent` | `5` | Maximum children per parent agent |

  <Note>
  Sub-agents require the `sub-agents` feature flag. Enable per-request via `override_subagents` on `AgentBuildConfig` or `enable_subagents` on `AgentFactory`.
  </Note>
</Accordion>

<Accordion title="Comms configuration">
  See the [comms guide](/comms) for full details.

  Agent-to-agent communication is configured under `[comms]`:

  ```toml .rkat/config.toml
  [comms]
  mode = "inproc"                    # Transport: "inproc", "tcp", or "uds"
  address = "127.0.0.1:4200"        # Listen address (tcp/uds only)
  auto_enable_for_subagents = false  # Auto-enable comms for spawned sub-agents
  ```

  <Note>
  Comms requires the `comms` feature flag. Enable at the factory level with `AgentFactory::comms(true)` and per-request with `host_mode` + `comms_name` on `AgentBuildConfig`.
  </Note>
</Accordion>

<Accordion title="Shell security">
  The built-in shell tool can be restricted using allow/deny lists. Configured under `[shell]`:

  ```toml .rkat/config.toml
  [shell]
  program = "bash"
  timeout_secs = 30
  security_mode = "unrestricted"  # "unrestricted", "allow_list", or "deny_list"
  security_patterns = []
  ```

  | Mode | Behavior |
  |------|----------|
  | `unrestricted` | No restrictions (default) |
  | `allow_list` | Only commands matching `security_patterns` globs are permitted |
  | `deny_list` | Commands matching `security_patterns` globs are blocked |

  Example with an allow list:

  ```toml .rkat/config.toml
  [shell]
  program = "bash"
  timeout_secs = 30
  security_mode = "allow_list"
  security_patterns = ["ls *", "cat *", "grep *", "find *"]
  ```
</Accordion>

<Accordion title="Logging">
  Meerkat uses the `tracing` crate. Configure via `RUST_LOG`:

  <CodeGroup>

  ```bash Basic info logging
  export RUST_LOG=info
  ```

  ```bash Debug Meerkat, info for dependencies
  export RUST_LOG=meerkat=debug,info
  ```

  ```bash Full trace logging
  export RUST_LOG=trace
  ```

  </CodeGroup>

  | Level | What gets logged |
  |-------|------------------|
  | `error` | Failures only |
  | `warn` | Warnings and above |
  | `info` | Session lifecycle, turns, completions |
  | `debug` | Tool calls, responses, retries |
  | `trace` | Wire-level protocol details |
</Accordion>

<Accordion title="MCP server configuration">
  See the [MCP guide](/mcp) for full details.

  <CodeGroup>

  ```json JSON config
  {
    "mcpServers": {
      "filesystem": {
        "command": "npx",
        "args": ["-y", "@anthropic/mcp-server-filesystem", "/tmp"],
        "env": {
          "DEBUG": "true"
        }
      }
    }
  }
  ```

  ```rust Programmatic
  use meerkat::{McpRouter, McpServerConfig};
  use std::collections::HashMap;

  let config = McpServerConfig {
      name: "filesystem".to_string(),
      command: "npx".to_string(),
      args: vec![
          "-y".to_string(),
          "@anthropic/mcp-server-filesystem".to_string(),
          "/tmp".to_string(),
      ],
      env: HashMap::new(),
  };

  let router = McpRouter::new();
  router.add_server(config).await?;
  ```

  </CodeGroup>

  CLI management:

  ```bash
  rkat mcp add <name> -- <command> [args...]   # Add stdio server
  rkat mcp add <name> --url <url>              # Add HTTP/SSE server
  rkat mcp list                                # List servers
  rkat mcp remove <name>                       # Remove server
  ```
</Accordion>

<Accordion title="REST API configuration">
  See the [REST guide](/rest) for full details.

  ```toml .rkat/config.toml
  [rest]
  host = "0.0.0.0"
  port = 3000

  [agent]
  model = "claude-opus-4-6"
  max_tokens_per_turn = 8192
  ```

  <CodeGroup>

  ```bash Development
  cargo run --package meerkat-rest
  ```

  ```bash Production
  cargo build --release --package meerkat-rest
  ./target/release/meerkat-rest
  ```

  </CodeGroup>
</Accordion>

<Accordion title="Programmatic configuration (SDK)">
  ### Quick builder

  ```rust
  use meerkat::BudgetLimits;
  use std::time::Duration;

  let result = meerkat::with_anthropic(api_key)
      .model("claude-opus-4-6")
      .system_prompt("You are helpful.")
      .max_tokens(2048)
      .with_budget(BudgetLimits {
          max_tokens: Some(50_000),
          max_duration: Some(Duration::from_secs(120)),
          max_tool_calls: Some(50),
      })
      .with_retry_policy(RetryPolicy {
          max_retries: 5,
          initial_delay: Duration::from_millis(500),
          max_delay: Duration::from_secs(30),
          multiplier: 2.0,
      })
      .run("Your prompt")
      .await?;
  ```

  ### Full AgentBuilder

  For complete control over individual components:

  ```rust
  use meerkat::{AgentBuilder, BudgetLimits, RetryPolicy};

  let mut agent = AgentBuilder::new()
      .model("claude-opus-4-6")
      .system_prompt("You are a helpful assistant.")
      .max_tokens_per_turn(4096)
      .budget(BudgetLimits {
          max_tokens: Some(100_000),
          max_duration: Some(Duration::from_secs(300)),
          max_tool_calls: Some(100),
      })
      .retry_policy(RetryPolicy {
          max_retries: 3,
          initial_delay: Duration::from_millis(500),
          max_delay: Duration::from_secs(10),
          multiplier: 2.0,
      })
      .resume_session(existing_session)
      .build(llm_client, tool_dispatcher, session_store);
  ```

  Use the quick builder for simple use cases and `AgentBuilder` when you need control over the LLM client, tool dispatcher, or session store.
</Accordion>

<Accordion title="Testing variables">
  These environment variables are used only when running the Meerkat test suite.

  | Variable | Description | Default |
  |----------|-------------|---------|
  | `RKAT_TEST_CLIENT` | Set to `1` to enable test client mode | unset |
  | `ANTHROPIC_MODEL` | Model for Anthropic E2E tests | `claude-opus-4-6` |
  | `OPENAI_MODEL` | Model for OpenAI E2E tests | `gpt-5.2` |
  | `GEMINI_MODEL` | Model for Gemini E2E tests | `gemini-3-flash-preview` |
  | `RUST_LOG` | Logging level filter (see logging section) | unset |
</Accordion>
