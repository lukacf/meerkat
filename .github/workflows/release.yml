name: Release

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:
    inputs:
      publish_release_packages:
        description: "Publish Rust/Python/TypeScript artifacts to registries"
        required: false
        default: false
        type: boolean

permissions:
  contents: write
  id-token: write

env:
  CARGO_TERM_COLOR: always

jobs:
  release_validate:
    name: Validate release branch/state
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          profile: minimal

      - name: Cache cargo registry
        uses: Swatinem/rust-cache@v2

      - name: Run preflight checks
        run: |
          make release-preflight
          if [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            make verify-version
          else
            echo "Skipping tag-version check (non-tag workflow trigger)."
          fi

  build_binaries:
    name: Build and package surface binaries
    needs: [release_validate]
    runs-on: ${{ matrix.runs-on }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - runs-on: ubuntu-latest
            target: x86_64-unknown-linux-gnu
            archive_ext: tar.gz
          - runs-on: macos-14
            target: aarch64-apple-darwin
            archive_ext: tar.gz
          - runs-on: macos-13
            target: x86_64-apple-darwin
            archive_ext: tar.gz
          - runs-on: windows-latest
            target: x86_64-pc-windows-msvc
            archive_ext: zip

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          profile: minimal

      - name: Add release target
        run: rustup target add ${{ matrix.target }}

      - name: Build surface binaries
        shell: bash
        run: |
          set -euo pipefail
          SURFACES=("rkat" "meerkat-rpc" "meerkat-rest" "meerkat-mcp-server")
          for surface in "${SURFACES[@]}"; do
            cargo build -p "$surface" --release --target "${{ matrix.target }}"
          done

      - name: Package artifacts
        shell: bash
        env:
          TARGET: ${{ matrix.target }}
          VERSION: ${{ github.ref_name }}
          ARCHIVE_EXT: ${{ matrix.archive_ext }}
        run: |
          set -euo pipefail
          SURFACES=("rkat" "meerkat-rpc" "meerkat-rest" "meerkat-mcp-server")
          mkdir -p dist
          VERSION="${VERSION#v}"
          VERSION="${VERSION//\//-}"

          for surface in "${SURFACES[@]}"; do
            if [[ "${RUNNER_OS}" == "Windows" ]]; then
              src="target/${TARGET}/release/${surface}.exe"
              artifact_name="${surface}-${VERSION}-${TARGET}.${ARCHIVE_EXT}"
            else
              src="target/${TARGET}/release/${surface}"
              artifact_name="${surface}-${VERSION}-${TARGET}.${ARCHIVE_EXT}"
            fi

            if [[ ! -f "$src" ]]; then
              echo "Missing expected binary at $src" >&2
              exit 1
            fi

            python3 - "$surface" "$src" "dist/$artifact_name" "$ARCHIVE_EXT" <<'PY'
            import pathlib
            import sys
            import tarfile
            import zipfile

            name, source_path, archive_path, archive_ext = sys.argv[1:5]
            source = pathlib.Path(source_path)
            archive = pathlib.Path(archive_path)

            if archive_ext == "zip":
                archive.parent.mkdir(parents=True, exist_ok=True)
                with zipfile.ZipFile(archive, "w", compression=zipfile.ZIP_DEFLATED) as zf:
                    zf.write(source, arcname=source.name)
            else:
                with tarfile.open(archive, "w:gz") as tf:
                    tf.add(source, arcname=source.name)

            print(f"packaged={name} -> {archive}")
            PY
          done

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: meerkat-${{ matrix.target }}-${{ matrix.runs-on }}
          path: dist/*
          if-no-files-found: error

  publish_github_release:
    name: Publish GitHub release assets
    if: startsWith(github.ref, 'refs/tags/v')
    needs: [build_binaries]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: release-artifacts

      - name: Build checksum manifest
        working-directory: release-artifacts
        run: |
          set -euo pipefail
          find . -type f \( -name "*.tar.gz" -o -name "*.zip" \) | sort > manifest_files.txt
          if [[ ! -s manifest_files.txt ]]; then
            echo "No release artifacts found" >&2
            exit 1
          fi
          xargs sha256sum < manifest_files.txt > checksums.sha256
          python3 - <<'PY'
          import os
          import json
          from pathlib import Path

          paths = [
              p.as_posix().lstrip("./")
              for p in sorted(Path(".").rglob("*"))
              if p.is_file() and (p.name.endswith(".tar.gz") or p.name.endswith(".zip"))
          ]

          tag = os.environ["GITHUB_REF_NAME"]
          manifest = {
              "version": tag.lstrip("v"),
              "tag": tag,
              "artifacts": paths,
              "checksums": "checksums.sha256",
          }

          with open("index.json", "w", encoding="utf-8") as f:
              json.dump(manifest, f, indent=2)
          PY

      - name: Publish GitHub release
        uses: softprops/action-gh-release@v2
        with:
          files: |
            release-artifacts/**/*.tar.gz
            release-artifacts/**/*.zip
            release-artifacts/checksums.sha256
            release-artifacts/index.json
          draft: false
          fail_on_unmatched_files: true

  publish_registries:
    name: Publish crates + SDK packages
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.publish_release_packages == 'true'
    needs: [release_validate, publish_github_release]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          profile: minimal

      - name: Cache cargo registry
        uses: Swatinem/rust-cache@v2

      - name: Install Python + Node tooling
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "22"

      - name: Install Python publishing tools
        run: python -m pip install --upgrade build twine

      - name: Publish Rust crates
        env:
          CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}
        run: |
          set -euo pipefail
          crates=(
            meerkat-core
            meerkat-contracts
            meerkat-client
            meerkat-store
            meerkat-tools
            meerkat-session
            meerkat-memory
            meerkat-mcp
            meerkat-mcp-server
            meerkat-hooks
            meerkat-skills
            meerkat-comms
            meerkat-rpc
            meerkat-rest
            meerkat
          )
          for c in "${crates[@]}"; do
            cargo publish -p "$c" --locked
          done

      - name: Publish Python SDK
        env:
          TWINE_USERNAME: __token__
          TWINE_PASSWORD: ${{ secrets.PYPI_API_TOKEN }}
        working-directory: sdks/python
        run: |
          set -euo pipefail
          python -m pip install --upgrade build twine
          rm -rf dist
          python -m build
          python -m twine upload dist/*

      - name: Publish TypeScript SDK
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
        working-directory: sdks/typescript
        run: |
          set -euo pipefail
          npm ci
          npm config set //registry.npmjs.org/:_authToken ${NODE_AUTH_TOKEN}
          npm run build
          npm publish --access public
