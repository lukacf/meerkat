# Legacy Surface Scan Report
Generated: "2026-02-13T12:11:06Z"

Terms:
- event/push
- send_message
- send_request
- send_response
- list_peers
- inject_with_subscription
- EventInjector
- SubscribableInjector
- interaction_subscriber
- event_injector

Scanned paths:
- docs
- .claude/skills/meerkat-platform
- sdks
- CHANGELOG.md
- meerkat/src
- meerkat-cli
- meerkat-core
- meerkat-comms
- meerkat-rest
- meerkat-rpc
- meerkat-session
- meerkat-tools
- meerkat-contracts/src/version.rs

Allowlist: /Users/luka/src/raik/scripts/m0_legacy_surface_allowlist.txt

Blocked matches: 0

No blocked matches found

Allowed matches: 269

docs/reference/comms-redesign-v6-hard-cut.md:21:- `event/push`
docs/reference/comms-redesign-v6-hard-cut.md:22:- `send_message`
docs/reference/comms-redesign-v6-hard-cut.md:23:- `send_request`
docs/reference/comms-redesign-v6-hard-cut.md:24:- `send_response`
docs/reference/comms-redesign-v6-hard-cut.md:25:- `list_peers`
docs/reference/comms-redesign-v6-hard-cut.md:296:- remove `send_message`, `send_request`, `send_response`, `list_peers`
docs/reference/comms-redesign-v6-hard-cut.md:323:- `event/push` handler and advertised method.
docs/reference/comms-redesign-v6-hard-cut.md:335:- `push_event` and event/push path usage.
docs/reference/comms-redesign-v6-hard-cut.md:347:- `event/push` helper path usage.
docs/reference/comms-redesign-v6-hard-cut.md:417:- Refactor: remove `event/push` fully.
docs/reference/comms-redesign-v6-hard-cut.md:429:- Refactor: delete old event/push code paths.
docs/reference/comms-redesign-v6-hard-cut.md:458:- RPC initialize method list must not include `event/push`.
docs/rust/advanced.mdx:233:use meerkat::{SubscribableInjector, AgentEvent, PlainEventSource};
docs/rust/advanced.mdx:235:let injector = service.event_injector(&session_id).await
docs/rust/advanced.mdx:238:let sub = injector.inject_with_subscription(
docs/rust/advanced.mdx:268:1. `inject_with_subscription()` generates a unique `InteractionId`, creates a channel (buffer: 4096), registers the sender in a subscriber registry, and injects the message into the inbox with the ID attached.
docs/rust/advanced.mdx:291:    let injector = service.event_injector(&session_id).await.unwrap();
docs/rust/advanced.mdx:292:    let sub = injector.inject_with_subscription(user_msg, PlainEventSource::Rpc)?;
docs/guides/comms.mdx:59:    plain -->|"EventInjector"| INBOX
docs/guides/comms.mdx:551:All events flow through the `EventInjector` trait into the bounded inbox, regardless of source.
docs/guides/comms.mdx:648:The service's `event_injector()` returns an `Arc<dyn SubscribableInjector>`. Use `inject()` for fire-and-forget (existing behavior), or `inject_with_subscription()` to get a dedicated event channel:
docs/guides/comms.mdx:651:use meerkat::{SubscribableInjector, AgentEvent, PlainEventSource};
docs/guides/comms.mdx:653:let injector = service.event_injector(&session_id).await
docs/guides/comms.mdx:660:let sub = injector.inject_with_subscription(
docs/guides/comms.mdx:696:- **Comms must be enabled.** Without comms, `event_injector()` returns `None`.
.claude/skills/meerkat-platform/SKILL.md:138:**External event ingestion:** External systems (webhooks, scripts, stdin) can push events into a running agent's inbox. All events flow through the `SubscribableInjector` trait (which extends `EventInjector`) into a bounded inbox, drained at turn boundaries (or continuously in host mode) and injected as user messages.
.claude/skills/meerkat-platform/SKILL.md:147:**Interaction-scoped streaming (Rust SDK):** When injecting events programmatically, use `inject_with_subscription()` instead of `inject()` to get a dedicated `mpsc::Receiver<AgentEvent>` scoped to that interaction. Events (`TextDelta`, `ToolCallRequested`, etc.) are mirrored to the subscriber during the turn that processes the injected message. The stream ends with exactly one terminal event: `InteractionComplete { result }` or `InteractionFailed { error }`. Backpressure drops intermediate events (with a `StreamTruncated` marker) but never the terminal. Requires host mode with a configured primary `event_tx` (typically via `AgentBuildConfig.event_tx`, then `run_host_mode()`) and comms enabled. The service's `event_injector(&session_id)` returns `Arc<dyn SubscribableInjector>`.
.claude/skills/meerkat-platform/references/api_reference.md:505:use meerkat::{SubscribableInjector, AgentEvent, PlainEventSource};
.claude/skills/meerkat-platform/references/api_reference.md:508:let injector = service.event_injector(&session_id).await
.claude/skills/meerkat-platform/references/api_reference.md:515:let sub = injector.inject_with_subscription(
CHANGELOG.md:73:- Comms tools: `comms_send`, `comms_request`, `comms_response`, `comms_list_peers`
meerkat/src/service_factory.rs:130:    // Remove when event/push is eradicated in M7/M12.
meerkat/src/service_factory.rs:131:    fn event_injector(&self) -> Option<Arc<dyn meerkat_core::SubscribableInjector>> {
meerkat/src/service_factory.rs:132:        self.agent.comms_arc()?.event_injector()
meerkat-cli/src/stdin_events.rs:4://! and injects them as `PlainEvent` items via the `EventInjector` trait.
meerkat-cli/src/stdin_events.rs:7:use meerkat_core::event_injector::{EventInjectorError, SubscribableInjector};
meerkat-cli/src/stdin_events.rs:23:pub fn spawn_stdin_reader(injector: Arc<dyn SubscribableInjector>) -> JoinHandle<()> {
meerkat-cli/src/stdin_events.rs:36:                Err(EventInjectorError::Full) => {
meerkat-cli/src/stdin_events.rs:39:                Err(EventInjectorError::Closed) => {
meerkat-cli/src/main.rs:1209:    // (and the EventInjector is available) before the first turn blocks.
meerkat-cli/src/main.rs:1234:                .event_injector(&info.session_id)
meerkat-cli/tests/e2e_rkat_comms.rs:489:            "You are Alice. Send a message to bob (peer address: tcp://{}) saying 'Hello from Alice!' using the send_message tool.",
meerkat-cli/tests/e2e_rkat_comms.rs:633:        .spawn("You are a responder. When you receive a request with intent 'calculate', compute x+y from params and send a response with the result using send_response tool.")
meerkat-cli/tests/e2e_rkat_comms.rs:644:            "Send a request to responder at tcp://{} with intent 'calculate' and params {{\"x\": 10, \"y\": 5}} using send_request tool. Wait for the response.",
meerkat-cli/tests/e2e_rkat_comms.rs:749:            "You are the coordinator. Send a message to worker-1 at tcp://{} and worker-2 at tcp://{} saying 'Start working!' using send_message tool for each.",
meerkat-core/src/lib.rs:14:pub mod event_injector;
meerkat-core/src/lib.rs:62:pub use event_injector::{
meerkat-core/src/lib.rs:63:    EventInjector, EventInjectorError, InteractionSubscription, SubscribableInjector,
meerkat-core/src/gateway.rs:453:            &["send_message", "list_peers"],
meerkat-core/src/gateway.rs:463:        assert!(tool_names.contains(&"send_message"));
meerkat-core/src/gateway.rs:464:        assert!(tool_names.contains(&"list_peers"));
meerkat-core/src/gateway.rs:480:            &["task_create", "send_message"],
meerkat-core/src/gateway.rs:484:            &["send_message", "list_peers"],
meerkat-core/src/gateway.rs:491:        assert!(err.to_string().contains("send_message"));
meerkat-core/src/gateway.rs:498:        let overlay = Arc::new(MockDispatcher::new("comms", &["send_message"]));
meerkat-core/src/gateway.rs:512:        let overlay = Arc::new(MockDispatcher::new("comms", &["send_message"]));
meerkat-core/src/gateway.rs:516:        let result = dispatch_json(&gateway, "send_message", json!({}))
meerkat-core/src/gateway.rs:520:        assert_eq!(result["tool"], "send_message");
meerkat-core/src/gateway.rs:537:        let comms = Arc::new(MockDispatcher::new("comms", &["send_message"]));
meerkat-core/src/gateway.rs:595:        let comms = Arc::new(MockDispatcher::new("comms", &["send_message"]));
meerkat-core/src/gateway.rs:631:        let comms = Arc::new(MockDispatcher::new("comms", &["send_message"]));
meerkat-core/src/gateway.rs:646:        let result = dispatch_json(&gateway, "send_message", json!({})).await;
meerkat-core/src/gateway.rs:654:        let result = dispatch_json(&gateway, "send_message", json!({})).await;
meerkat-core/src/gateway.rs:663:        let base = Arc::new(MockDispatcher::new("base", &["send_message"]));
meerkat-core/src/gateway.rs:664:        let comms = Arc::new(MockDispatcher::new("comms", &["send_message"]));
meerkat-core/src/gateway.rs:701:        let overlay = Arc::new(MockDispatcher::new("comms", &["send_message"]));
meerkat-core/src/gateway.rs:722:                "send_message",
meerkat-core/src/gateway.rs:723:                "send_request",
meerkat-core/src/gateway.rs:724:                "send_response",
meerkat-core/src/gateway.rs:725:                "list_peers",
meerkat-core/src/gateway.rs:752:        assert!(names.contains(&"send_message"));
meerkat-core/src/gateway.rs:753:        assert!(names.contains(&"send_request"));
meerkat-core/src/gateway.rs:754:        assert!(names.contains(&"send_response"));
meerkat-core/src/gateway.rs:755:        assert!(names.contains(&"list_peers"));
meerkat-core/src/event_injector.rs:3://! Surfaces (REST, CLI, RPC) use `EventInjector` to push external events
meerkat-core/src/event_injector.rs:5://! `meerkat-comms` provides the concrete implementation (`CommsEventInjector`)
meerkat-core/src/event_injector.rs:12:pub enum EventInjectorError {
meerkat-core/src/event_injector.rs:19:impl std::fmt::Display for EventInjectorError {
meerkat-core/src/event_injector.rs:28:impl std::error::Error for EventInjectorError {}
meerkat-core/src/event_injector.rs:34:pub trait EventInjector: Send + Sync {
meerkat-core/src/event_injector.rs:39:    fn inject(&self, body: String, source: PlainEventSource) -> Result<(), EventInjectorError>;
meerkat-core/src/event_injector.rs:42:/// A subscription handle returned by `SubscribableInjector::inject_with_subscription`.
meerkat-core/src/event_injector.rs:58:pub trait SubscribableInjector: EventInjector {
meerkat-core/src/event_injector.rs:67:    fn inject_with_subscription(
meerkat-core/src/event_injector.rs:71:    ) -> Result<InteractionSubscription, EventInjectorError>;
meerkat-core/src/event_injector.rs:81:    /// Mock EventInjector for testing — records injected events.
meerkat-core/src/event_injector.rs:82:    struct MockEventInjector {
meerkat-core/src/event_injector.rs:86:    impl MockEventInjector {
meerkat-core/src/event_injector.rs:94:    impl EventInjector for MockEventInjector {
meerkat-core/src/event_injector.rs:95:        fn inject(&self, body: String, source: PlainEventSource) -> Result<(), EventInjectorError> {
meerkat-core/src/event_injector.rs:102:    fn test_event_injector_trait_compiles() {
meerkat-core/src/event_injector.rs:103:        let injector = MockEventInjector::new();
meerkat-core/src/event_injector.rs:115:    fn test_event_injector_as_dyn_trait() {
meerkat-core/src/event_injector.rs:116:        let injector: Arc<dyn EventInjector> = Arc::new(MockEventInjector::new());
meerkat-core/src/event_injector.rs:123:    fn test_event_injector_error_display() {
meerkat-core/src/event_injector.rs:124:        assert_eq!(EventInjectorError::Full.to_string(), "inbox full");
meerkat-core/src/event_injector.rs:125:        assert_eq!(EventInjectorError::Closed.to_string(), "inbox closed");
meerkat-core/src/agent.rs:234:    fn event_injector(&self) -> Option<Arc<dyn crate::SubscribableInjector>> {
meerkat-core/src/agent.rs:257:    /// Returns the event sender if a subscriber was registered (via `inject_with_subscription`).
meerkat-core/src/agent.rs:259:    fn interaction_subscriber(
meerkat-core/src/agent.rs:271:        self.interaction_subscriber(_id)
meerkat-core/src/agent/comms_impl.rs:186:                    let subscriber = comms.interaction_subscriber(&interaction.id);
meerkat-core/src/agent/comms_impl.rs:526:        fn interaction_subscriber(
meerkat-comms/tests/e2e.rs:211:        .send_message("peer-b", "Hello from A!".to_string())
meerkat-comms/tests/e2e.rs:264:        .send_message("peer-b", "Hello via TCP!".to_string())
meerkat-comms/tests/e2e.rs:330:        .send_request("peer-b", "review-pr".to_string(), json!({"pr": 42}))
meerkat-comms/tests/e2e.rs:389:    let send_result = router_a.send_message("peer-b", "Hello!".to_string()).await;
meerkat-comms/tests/e2e.rs:487:    let send_b = router_a.send_message("peer-b", "Hello B!".to_string());
meerkat-comms/tests/e2e.rs:488:    let send_c = router_a.send_message("peer-c", "Hello C!".to_string());
meerkat-comms/tests/router_integration.rs:130:    let result = router.send_message("test-peer", "hello".to_string()).await;
meerkat-comms/tests/router_integration.rs:149:        .send_message("unknown-peer", "hello".to_string())
meerkat-comms/tests/router_integration.rs:182:    let result = router.send_message("test-peer", "hello".to_string()).await;
meerkat-comms/tests/router_integration.rs:233:    let result = router.send_message("test-peer", "hello".to_string()).await;
meerkat-comms/tests/router_integration.rs:282:    let result = router.send_message("test-peer", "hello".to_string()).await;
meerkat-comms/tests/router_integration.rs:320:    let result = router.send_message("test-peer", "hello".to_string()).await;
meerkat-comms/tests/router_integration.rs:328:async fn integration_real_send_message() {
meerkat-comms/tests/router_integration.rs:379:        .send_message("test-peer", "test body".to_string())
meerkat-comms/tests/router_integration.rs:387:async fn integration_real_send_request() {
meerkat-comms/tests/router_integration.rs:439:        .send_request(
meerkat-comms/tests/router_integration.rs:451:async fn integration_real_send_response() {
meerkat-comms/tests/router_integration.rs:496:        .send_response(
meerkat-comms/tests/router_integration.rs:509:async fn integration_real_send_response_no_ack_wait() {
meerkat-comms/tests/router_integration.rs:541:        .send_response(
meerkat-comms/tests/router_integration.rs:550:    assert!(result.is_ok(), "send_response should succeed");
meerkat-comms/tests/router_integration.rs:553:        "send_response should not wait for ack, took {:?}",
meerkat-comms/tests/router_integration.rs:598:        .send_message("receiver-agent", "hello via inproc".to_string())
meerkat-comms/tests/router_integration.rs:650:        .send_message("missing-agent", "hello".to_string())
meerkat-comms/tests/router_integration.rs:694:        .send_request(
meerkat-comms/src/lib.rs:15:pub mod event_injector;
meerkat-comms/src/lib.rs:21:pub use event_injector::CommsEventInjector;
meerkat-comms/src/router.rs:209:    pub async fn send_message(&self, peer_name: &str, body: String) -> Result<(), SendError> {
meerkat-comms/src/router.rs:213:    pub async fn send_request(
meerkat-comms/src/router.rs:223:    pub async fn send_response(
meerkat-comms/src/types.rs:145:        /// Set by `inject_with_subscription`, `None` for untracked events.
meerkat-comms/src/event_injector.rs:1://! Concrete `EventInjector` implementation wrapping `InboxSender`.
meerkat-comms/src/event_injector.rs:6:use meerkat_core::event_injector::{EventInjector, EventInjectorError};
meerkat-comms/src/event_injector.rs:11:/// `inject_with_subscription()` and removed (one-shot) by
meerkat-comms/src/event_injector.rs:12:/// `CommsRuntime::interaction_subscriber()`.
meerkat-comms/src/event_injector.rs:26:/// This is the concrete implementation of `EventInjector` that wraps an
meerkat-comms/src/event_injector.rs:27:/// `InboxSender`. Surfaces receive `Arc<dyn EventInjector>` — this type
meerkat-comms/src/event_injector.rs:29:pub struct CommsEventInjector {
meerkat-comms/src/event_injector.rs:34:impl CommsEventInjector {
meerkat-comms/src/event_injector.rs:44:impl EventInjector for CommsEventInjector {
meerkat-comms/src/event_injector.rs:45:    fn inject(&self, body: String, source: PlainEventSource) -> Result<(), EventInjectorError> {
meerkat-comms/src/event_injector.rs:53:                InboxError::Full => EventInjectorError::Full,
meerkat-comms/src/event_injector.rs:54:                InboxError::Closed => EventInjectorError::Closed,
meerkat-comms/src/event_injector.rs:59:impl meerkat_core::SubscribableInjector for CommsEventInjector {
meerkat-comms/src/event_injector.rs:60:    fn inject_with_subscription(
meerkat-comms/src/event_injector.rs:64:    ) -> Result<meerkat_core::InteractionSubscription, EventInjectorError> {
meerkat-comms/src/event_injector.rs:80:                InboxError::Full => EventInjectorError::Full,
meerkat-comms/src/event_injector.rs:81:                InboxError::Closed => EventInjectorError::Closed,
meerkat-comms/src/event_injector.rs:99:    fn test_comms_event_injector_sends_to_inbox() {
meerkat-comms/src/event_injector.rs:101:        let injector = CommsEventInjector::new(sender, new_subscriber_registry());
meerkat-comms/src/event_injector.rs:119:    fn test_comms_event_injector_reports_full() {
meerkat-comms/src/event_injector.rs:122:        let injector = CommsEventInjector::new(sender, new_subscriber_registry());
meerkat-comms/src/event_injector.rs:132:            matches!(result, Err(EventInjectorError::Full)),
meerkat-comms/src/event_injector.rs:138:    fn test_comms_event_injector_as_dyn() {
meerkat-comms/src/event_injector.rs:142:        let injector: Arc<dyn EventInjector> =
meerkat-comms/src/event_injector.rs:143:            Arc::new(CommsEventInjector::new(sender, new_subscriber_registry()));
meerkat-comms/src/event_injector.rs:154:    fn test_inject_with_subscription_stores_subscriber_and_sends_item() {
meerkat-comms/src/event_injector.rs:155:        use meerkat_core::SubscribableInjector;
meerkat-comms/src/event_injector.rs:159:        let injector = CommsEventInjector::new(sender, registry.clone());
meerkat-comms/src/event_injector.rs:162:            .inject_with_subscription("tracked".to_string(), PlainEventSource::Rpc)
meerkat-comms/src/event_injector.rs:185:    fn test_inject_with_subscription_cleans_up_on_full() {
meerkat-comms/src/event_injector.rs:186:        use meerkat_core::SubscribableInjector;
meerkat-comms/src/event_injector.rs:190:        let injector = CommsEventInjector::new(sender, registry.clone());
meerkat-comms/src/event_injector.rs:198:        let result = injector.inject_with_subscription("second".to_string(), PlainEventSource::Tcp);
meerkat-comms/src/event_injector.rs:199:        assert!(matches!(result, Err(EventInjectorError::Full)));
meerkat-comms/src/event_injector.rs:206:    fn test_inject_with_subscription_cleans_up_on_closed_inbox() {
meerkat-comms/src/event_injector.rs:207:        use meerkat_core::SubscribableInjector;
meerkat-comms/src/event_injector.rs:213:        let injector = CommsEventInjector::new(sender, registry.clone());
meerkat-comms/src/event_injector.rs:214:        let result = injector.inject_with_subscription("closed".to_string(), PlainEventSource::Tcp);
meerkat-comms/src/event_injector.rs:216:        assert!(matches!(result, Err(EventInjectorError::Closed)));
meerkat-comms/src/mcp/tools.rs:116:                .send_message(&input.to, body)
meerkat-comms/src/mcp/tools.rs:125:                .send_request(&input.to, intent, params)
meerkat-comms/src/mcp/tools.rs:146:                .send_response(&input.to, in_reply_to, status, result)
meerkat-comms/src/mcp/tools.rs:304:        assert!(handle_tools_call(&ctx, "send_message", &json!({}))
meerkat-comms/src/mcp/tools.rs:307:        assert!(handle_tools_call(&ctx, "list_peers", &json!({}))
meerkat-comms/skills/multi-agent-comms/SKILL.md:26:- Use `comms_list_peers` to see connected peers
meerkat-comms/src/agent/dispatcher.rs:72:    "send_message",
meerkat-comms/src/agent/dispatcher.rs:73:    "send_request",
meerkat-comms/src/agent/dispatcher.rs:74:    "send_response",
meerkat-comms/src/agent/dispatcher.rs:75:    "list_peers",
meerkat-comms/src/agent/types.rs:153:        /// The request ID (for send_response).
meerkat-comms/src/agent/types.rs:290:                     To respond, use send_response with peer=\"{}\", request_id=\"{}\"",
meerkat-comms/src/agent/types.rs:623:        assert!(text.contains("send_response"));
meerkat-comms/src/runtime/comms_runtime.rs:191:    fn event_injector(&self) -> Option<Arc<dyn meerkat_core::SubscribableInjector>> {
meerkat-comms/src/runtime/comms_runtime.rs:192:        Some(self.event_injector())
meerkat-comms/src/runtime/comms_runtime.rs:255:                    let injector = CoreCommsRuntime::event_injector(self).ok_or_else(|| {
meerkat-comms/src/runtime/comms_runtime.rs:260:                        .map_err(map_event_injector_error)?;
meerkat-comms/src/runtime/comms_runtime.rs:455:    fn interaction_subscriber(
meerkat-comms/src/runtime/comms_runtime.rs:478:fn map_event_injector_error(error: meerkat_core::event_injector::EventInjectorError) -> SendError {
meerkat-comms/src/runtime/comms_runtime.rs:480:        meerkat_core::event_injector::EventInjectorError::Full => {
meerkat-comms/src/runtime/comms_runtime.rs:483:        meerkat_core::event_injector::EventInjectorError::Closed => SendError::InputClosed,
meerkat-comms/src/runtime/comms_runtime.rs:531:    subscriber_registry: crate::event_injector::SubscriberRegistry,
meerkat-comms/src/runtime/comms_runtime.rs:566:            subscriber_registry: crate::event_injector::new_subscriber_registry(),
meerkat-comms/src/runtime/comms_runtime.rs:611:            subscriber_registry: crate::event_injector::new_subscriber_registry(),
meerkat-comms/src/runtime/comms_runtime.rs:824:    pub fn event_injector(&self) -> Arc<dyn meerkat_core::SubscribableInjector> {
meerkat-comms/src/runtime/comms_runtime.rs:825:        Arc::new(crate::CommsEventInjector::new(
meerkat-comms/src/runtime/comms_runtime.rs:1048:    use crate::event_injector::CommsEventInjector;
meerkat-comms/src/runtime/comms_runtime.rs:1051:    use meerkat_core::SubscribableInjector;
meerkat-comms/src/runtime/comms_runtime.rs:1269:        let injector = CommsEventInjector::new(
meerkat-comms/src/runtime/comms_runtime.rs:1274:            .inject_with_subscription("tracked".to_string(), meerkat_core::PlainEventSource::Rpc)
meerkat-comms/src/runtime/comms_runtime.rs:1282:        let first = CoreCommsRuntime::interaction_subscriber(&runtime, &tracked_id);
meerkat-comms/src/runtime/comms_runtime.rs:1284:        let second = CoreCommsRuntime::interaction_subscriber(&runtime, &tracked_id);
meerkat-comms/src/runtime/comms_runtime.rs:1311:    fn test_interaction_subscriber_correlation_miss_returns_none() {
meerkat-comms/src/runtime/comms_runtime.rs:1314:        let sender = CoreCommsRuntime::interaction_subscriber(&runtime, &random);
meerkat-rest/src/lib.rs:572:        .event_injector(&session_id)
meerkat-rest/src/lib.rs:582:        Err(meerkat_core::EventInjectorError::Full) => Err(ApiError::ServiceUnavailable(
meerkat-rest/src/lib.rs:585:        Err(meerkat_core::EventInjectorError::Closed) => {
meerkat-rpc/src/handlers/mod.rs:9:// BRIDGE(M7→M12): Legacy event/push handler, kept for internal reference.
meerkat-rpc/tests/integration_server.rs:96:async fn send_request(writer: &mut tokio::io::DuplexStream, request: &serde_json::Value) {
meerkat-rpc/tests/integration_server.rs:137:    send_request(&mut writer, &req).await;
meerkat-rpc/tests/integration_server.rs:172:    send_request(&mut writer, &create_req).await;
meerkat-rpc/tests/integration_server.rs:200:    send_request(&mut writer, &turn_req).await;
meerkat-rpc/tests/integration_server.rs:266:    send_request(&mut writer, &req).await;
meerkat-rpc/tests/integration_server.rs:292:    send_request(&mut writer, &get_req).await;
meerkat-rpc/tests/integration_server.rs:311:    send_request(&mut writer, &patch_req).await;
meerkat-rpc/tests/integration_server.rs:328:    send_request(&mut writer, &get_req2).await;
meerkat-rpc/tests/integration_server.rs:350:    send_request(&mut writer, &create1).await;
meerkat-rpc/tests/integration_server.rs:361:    send_request(&mut writer, &create2).await;
meerkat-rpc/tests/integration_server.rs:372:    send_request(&mut writer, &list_req).await;
meerkat-rpc/tests/integration_server.rs:411:    send_request(&mut writer, &req).await;
meerkat-rpc/tests/e2e_smoke.rs:74:async fn send_request(writer: &mut tokio::io::DuplexStream, request: &serde_json::Value) {
meerkat-rpc/tests/e2e_smoke.rs:147:    send_request(&mut writer, &init_req).await;
meerkat-rpc/tests/e2e_smoke.rs:170:    send_request(&mut writer, &create_req).await;
meerkat-rpc/tests/e2e_smoke.rs:202:    send_request(&mut writer, &turn_req).await;
meerkat-rpc/tests/e2e_smoke.rs:235:    send_request(&mut writer, &read_req).await;
meerkat-rpc/tests/e2e_smoke.rs:257:    send_request(&mut writer, &list_req).await;
meerkat-rpc/tests/e2e_smoke.rs:285:    send_request(&mut writer, &archive_req).await;
meerkat-rpc/tests/e2e_smoke.rs:303:    send_request(&mut writer, &list_req2).await;
meerkat-rpc/tests/e2e_smoke.rs:369:    send_request(
meerkat-rpc/tests/e2e_smoke.rs:387:    send_request(
meerkat-rpc/tests/e2e_smoke.rs:420:    send_request(
meerkat-rpc/tests/e2e_smoke.rs:442:    send_request(
meerkat-rpc/tests/e2e_smoke.rs:453:    send_request(
meerkat-rpc/tests/e2e_smoke.rs:490:    send_request(
meerkat-rpc/tests/e2e_smoke.rs:515:    send_request(
meerkat-rpc/tests/e2e_smoke.rs:526:    send_request(
meerkat-rpc/tests/e2e_smoke.rs:543:    send_request(
meerkat-rpc/tests/e2e_smoke.rs:569:    send_request(
meerkat-rpc/tests/e2e_smoke.rs:579:    send_request(
meerkat-rpc/tests/e2e_smoke.rs:628:    send_request(&mut writer, &init_req).await;
meerkat-rpc/tests/e2e_smoke.rs:650:    send_request(&mut writer, &create_req).await;
meerkat-rpc/tests/e2e_smoke.rs:711:    send_request(&mut writer, &turn_req).await;
meerkat-rpc/src/handlers/event.rs:1://! `event/push` handler — push external events into a session's inbox.
meerkat-rpc/src/handlers/event.rs:12:/// Parameters for `event/push`.
meerkat-rpc/src/handlers/event.rs:20:/// Handle `event/push` — inject an external event into a session's inbox.
meerkat-rpc/src/handlers/event.rs:55:    let injector = match runtime.event_injector(&session_id).await {
meerkat-rpc/src/handlers/event.rs:69:        Err(meerkat_core::EventInjectorError::Full) => {
meerkat-rpc/src/handlers/event.rs:72:        Err(meerkat_core::EventInjectorError::Closed) => {
meerkat-rpc/src/router.rs:109:            // M12: event/push removed. Use comms/send instead.
meerkat-rpc/src/session_runtime.rs:314:    /// Use `inject()` for fire-and-forget or `inject_with_subscription()`
meerkat-rpc/src/session_runtime.rs:316:    pub async fn event_injector(
meerkat-rpc/src/session_runtime.rs:319:    ) -> Option<std::sync::Arc<dyn meerkat_core::SubscribableInjector>> {
meerkat-rpc/src/session_runtime.rs:320:        self.service.event_injector(session_id).await
meerkat-session/src/ephemeral.rs:95:    event_injector: Option<Arc<dyn meerkat_core::SubscribableInjector>>,
meerkat-session/src/ephemeral.rs:160:    /// `inject_with_subscription()` for interaction-scoped streaming.
meerkat-session/src/ephemeral.rs:161:    fn event_injector(&self) -> Option<Arc<dyn meerkat_core::SubscribableInjector>> {
meerkat-session/src/ephemeral.rs:240:    /// Use `inject()` for fire-and-forget or `inject_with_subscription()`
meerkat-session/src/ephemeral.rs:242:    pub async fn event_injector(
meerkat-session/src/ephemeral.rs:245:    ) -> Option<Arc<dyn meerkat_core::SubscribableInjector>> {
meerkat-session/src/ephemeral.rs:249:            .and_then(|h| h.event_injector.clone())
meerkat-session/src/ephemeral.rs:326:        let event_injector = agent.event_injector();
meerkat-session/src/ephemeral.rs:358:            event_injector,
meerkat-tools/src/builtin/sub_agent/tool_set.rs:88:To send messages to running sub-agents, use the `send_message` tool. Sub-agents automatically
meerkat-tools/src/builtin/sub_agent/spawn.rs:188:  send_message("{parent_name}", "your message here")
meerkat-tools/src/builtin/sub_agent/spawn.rs:200:        "To message this child: send_message(\"{child_name}\", \"your message\")",
meerkat-tools/src/builtin/sub_agent/fork.rs:146:        "To message this fork: send_message(\"{child_name}\", \"your message\")",
