---
title: "Tools and stores"
description: "Rust SDK reference for the tool system, session stores, and MCP integration."
icon: "screwdriver-wrench"
---

## Tool system

### Defining tools

Define tools using JSON Schema:

```rust
use meerkat::ToolDef;
use serde_json::json;

let tool = ToolDef {
    name: "get_weather".to_string(),
    description: "Get current weather for a city".to_string(),
    input_schema: json!({
        "type": "object",
        "properties": {
            "city": {
                "type": "string",
                "description": "City name"
            },
            "units": {
                "type": "string",
                "enum": ["celsius", "fahrenheit"],
                "default": "celsius"
            }
        },
        "required": ["city"]
    }),
};
```

### Implementing AgentToolDispatcher

The `AgentToolDispatcher` trait connects your tools to the agent:

```rust
use async_trait::async_trait;
use meerkat::{AgentToolDispatcher, ToolCallView, ToolDef, ToolResult};
use meerkat::error::ToolError;
use serde_json::json;
use std::sync::Arc;

struct MyToolDispatcher;

#[async_trait]
impl AgentToolDispatcher for MyToolDispatcher {
    fn tools(&self) -> Arc<[Arc<ToolDef>]> {
        vec![
            Arc::new(ToolDef {
                name: "search".to_string(),
                description: "Search the web".to_string(),
                input_schema: json!({
                    "type": "object",
                    "properties": {
                        "query": {"type": "string"}
                    },
                    "required": ["query"]
                }),
            }),
        ].into()
    }

    async fn dispatch(&self, call: ToolCallView<'_>) -> Result<ToolResult, ToolError> {
        match call.name {
            "search" => {
                #[derive(serde::Deserialize)]
                struct Args { query: String }

                let args: Args = call.parse_args()
                    .map_err(|e| ToolError::InvalidArguments(e.to_string()))?;
                Ok(ToolResult::success(call.id, format!("Results for: {}", args.query)))
            }
            _ => Err(ToolError::not_found(call.name)),
        }
    }
}
```

<Accordion title="ToolRegistry (dynamic registration)">
For dynamic tool registration:

```rust
use meerkat::ToolRegistry;

let mut registry = ToolRegistry::new();

registry.register(tool_def, Box::new(|args| {
    Box::pin(async move {
        Ok("result".to_string())
    })
}));

let tools = registry.tools();
```
</Accordion>

---

## Session stores

<Tabs>
  <Tab title="JsonlStore">
    File-based persistence using JSONL format:

    ```rust
    use meerkat::JsonlStore;
    use std::path::PathBuf;

    let store = JsonlStore::new(PathBuf::from("./sessions"));
    store.init().await?;

    store.save(&session).await?;
    let session = store.load(&session_id).await?;
    store.delete(&session_id).await?;
    ```
  </Tab>
  <Tab title="MemoryStore">
    In-memory storage for testing:

    ```rust
    use meerkat::MemoryStore;

    let store = MemoryStore::new();
    store.save(&session).await?;
    let loaded = store.load(&session_id).await?;
    ```
  </Tab>
</Tabs>

<Accordion title="Implementing a custom store">
Implement the `SessionStore` trait and pass it to `AgentFactory::session_store()`:

```rust
use async_trait::async_trait;
use meerkat::{AgentFactory, SessionStore, SessionFilter, StoreError, Session, SessionId};
use meerkat_core::SessionMeta;
use std::sync::Arc;

struct BigQueryStore { /* your storage backend */ }

#[async_trait]
impl SessionStore for BigQueryStore {
    async fn save(&self, session: &Session) -> Result<(), StoreError> {
        // Persist session to BigQuery
        Ok(())
    }

    async fn load(&self, id: &SessionId) -> Result<Option<Session>, StoreError> {
        // Load session by ID
        Ok(None)
    }

    async fn list(&self, filter: SessionFilter) -> Result<Vec<SessionMeta>, StoreError> {
        Ok(vec![])
    }

    async fn delete(&self, id: &SessionId) -> Result<(), StoreError> {
        Ok(())
    }
}

// Wire into AgentFactory â€” all factory features (comms, hooks, skills, etc.) work unchanged
let store: Arc<dyn SessionStore> = Arc::new(BigQueryStore { /* ... */ });
let factory = AgentFactory::new(".rkat/sessions")
    .session_store(store)
    .builtins(true)
    .shell(true);

let mut agent = factory.build_agent(build_config, &config).await?;
// Agent auto-saves to BigQuery after each turn
```

<Note>
Prefer `SessionStore` + `session_store()` over implementing `AgentSessionStore` directly.
`SessionStore` is the richer trait (with `list`, `delete`, `exists`) and `AgentFactory`
automatically wraps it via `StoreAdapter`. Implementing `AgentSessionStore` directly
bypasses the factory and loses comms, hooks, skills, and sub-agent wiring.
</Note>
</Accordion>

---

## MCP integration

Route tool calls across multiple MCP servers:

```rust
use meerkat::{McpRouter, McpServerConfig};
use std::collections::HashMap;

let mut router = McpRouter::new();

// Add stdio-based MCP server
let config = McpServerConfig::stdio(
    "my-server",
    "/path/to/mcp-server".to_string(),
    vec!["--arg".to_string()],
    HashMap::new(),
);
router.add_server(config).await?;

// Add HTTP/SSE-based MCP server
let config = McpServerConfig::http(
    "remote-server",
    "https://mcp.example.com/sse".to_string(),
);
router.add_server(config).await?;

// List all available tools
let tools = router.list_tools().await?;

// Call a tool
let result = router.call_tool("tool_name", &args).await?;

// Graceful shutdown
router.shutdown().await;
```

---

## See also

- [Rust SDK overview](/rust/overview) - getting started, sessions, events
- [Rust SDK advanced](/rust/advanced) - AgentBuilder, providers, sub-agents
- [Tools concept](/concepts/tools) - how the tool system works
