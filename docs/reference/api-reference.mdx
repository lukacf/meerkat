---
title: "API reference"
description: "Index of public types, traits, and error codes in Meerkat."
icon: "book"
---

This page is a quick-lookup index. For detailed usage with examples, see the [Rust SDK reference](/rust/overview).

## Core types

| Type | Module | Purpose |
|------|--------|---------|
| `Agent` | `meerkat_core` | Main agent execution engine |
| `AgentBuilder` | `meerkat_core` | Builder pattern for agent construction |
| `Session` | `meerkat_core` | Conversation state container |
| `SessionId` | `meerkat_core` | Unique session identifier (UUIDv7) |
| `Message` | `meerkat_core` | Conversation message enum (`System`, `User`, `Assistant`, `BlockAssistant`, `ToolResults`) |
| `ToolDef` | `meerkat_core` | Tool definition (name, description, JSON Schema) |
| `ToolCall` | `meerkat_core` | Tool invocation request from the model |
| `ToolCallView` | `meerkat_core` | Zero-allocation borrowed view of a tool call |
| `ToolResult` | `meerkat_core` | Tool execution result |
| `Usage` | `meerkat_core` | Token usage tracking |
| `StopReason` | `meerkat_core` | Why the LLM stopped (`EndTurn`, `ToolUse`, `MaxTokens`, `StopSequence`, `ContentFilter`, `Cancelled`) |
| `RunResult` | `meerkat_core` | Agent execution result (text, session ID, usage, structured output) |
| `AgentEvent` | `meerkat_core` | Streaming events during execution |
| `AgentError` | `meerkat_core` | Error types (LLM, tool, budget, hook, cancellation) |
| `BudgetLimits` | `meerkat_core` | Resource constraints (tokens, duration, tool calls) |
| `RetryPolicy` | `meerkat_core` | Exponential backoff configuration |
| `MobRun` | `meerkat_mob` | Persisted flow run aggregate |
| `MobRunStatus` | `meerkat_mob` | Flow run lifecycle (`pending`, `running`, `completed`, `failed`, `canceled`) |
| `StepLedgerEntry` | `meerkat_mob` | Per-target step execution record |
| `FailureLedgerEntry` | `meerkat_mob` | Flow-level failure log record |
| `FlowRunConfig` | `meerkat_mob` | Immutable per-run config snapshot |

## Traits

| Trait | Module | Purpose | Detailed docs |
|-------|--------|---------|---------------|
| `AgentLlmClient` | `meerkat_core` | LLM provider abstraction | [Rust SDK: providers](/rust/advanced#providers) |
| `AgentToolDispatcher` | `meerkat_core` | Tool routing abstraction | [Rust SDK: tool system](/rust/tools-and-stores#tool-system) |
| `AgentSessionStore` | `meerkat_core` | Session persistence abstraction | [Rust SDK: session stores](/rust/tools-and-stores#session-stores) |
| `SessionService` | `meerkat_core::service` | Session lifecycle (create/turn/interrupt/read/list/archive) | [Rust SDK: sessions](/rust/overview#sessions) |
| `Compactor` | `meerkat_core` | Context compaction strategy | [Memory guide](/guides/memory) |
| `MemoryStore` | `meerkat_core` | Semantic memory indexing | [Memory guide](/guides/memory) |
| `SkillEngine` | `meerkat_core::skills` | Skill loading and injection | [Skills guide](/guides/skills) |
| `SkillSource` | `meerkat_core::skills` | Skill discovery from various sources | [Skills guide](/guides/skills) |
| `HookEngine` | `meerkat_core` | Hook pipeline execution | [Hooks guide](/guides/hooks) |
| `FlowTurnExecutor` | `meerkat_mob` | Runtime boundary between flow engine and dispatch/turn transport | [Mobs](/guides/mobs) |

## Mobs (Rust SDK)

Mob runtime APIs live primarily in:

- `meerkat_mob` (core runtime)
- `meerkat_mob_mcp` (tool-dispatch helpers)

### Core Rust types

| Type | Purpose |
|------|---------|
| `MobDefinition` | Declarative mob structure (profiles, wiring, topology, limits, flows) |
| `MobStorage` | Event/run/spec storage bundle (in-memory or redb) |
| `MobBuilder` | Construct or resume mob runtime |
| `MobHandle` | Runtime handle for lifecycle, membership, wiring, turns, flows, tasks |
| `MobSessionService` | Session-service bridge trait required by mob runtime |
| `MobState` | Lifecycle state (`Creating`, `Running`, `Stopped`, `Completed`, `Destroyed`) |
| `MobRun` | Persisted flow run aggregate |
| `SpawnMemberSpec` | Batch spawn input contract (`profile_name`, `meerkat_id`, `initial_message`, `runtime_mode`, `backend`) |

### `MobBuilder` methods

| Method | Purpose |
|------|---------|
| `MobBuilder::new(definition, storage)` | Build a new mob |
| `MobBuilder::for_resume(storage)` | Resume from persisted events |
| `with_session_service(Arc<dyn MobSessionService>)` | Attach required session bridge |
| `allow_ephemeral_sessions(bool)` | Allow non-persistent session services (dev/test) |
| `notify_orchestrator_on_resume(bool)` | Control resume notification behavior |
| `register_tool_bundle(name, dispatcher)` | Register named Rust tool bundle |
| `create().await` | Validate + create runtime |
| `resume().await` | Rehydrate runtime from store |

### `MobHandle` methods

| Method | Purpose |
|------|---------|
| `status()` | Current lifecycle state |
| `roster().await` / `list_members().await` | Membership inspection |
| `spawn(...).await` | Spawn member (returns `MemberRef`) |
| `spawn_many(Vec<SpawnMemberSpec>).await` | Batch spawn members in parallel (results preserve input order) |
| `spawn_with_backend(...).await` | Spawn member with explicit backend override |
| `spawn_with_options(...).await` | Spawn member with runtime mode and backend overrides |
| `retire(...).await` | Retire member |
| `wire(...).await` / `unwire(...).await` | Peer graph mutation |
| `send_message(...).await` / `internal_turn(...).await` | Turn dispatch |
| `stop().await` / `resume().await` / `complete().await` / `destroy().await` | Lifecycle transitions |
| `list_flows()` / `run_flow(...).await` / `flow_status(...).await` / `cancel_flow(...).await` | Flow runtime control |
| `task_create(...).await` / `task_update(...).await` / `task_list().await` | Shared task board |
| `events().poll(...)` / `poll_events(...)` | Event stream access |

### Rust example

```rust
use std::sync::Arc;
use meerkat_mob::{
    FlowId, MeerkatId, MobBuilder, MobDefinition, MobSessionService, MobStorage, ProfileName,
};

async fn orchestrate(
    definition_toml: &str,
    session_service: Arc<dyn MobSessionService>,
) -> Result<(), Box<dyn std::error::Error>> {
    let definition = MobDefinition::from_toml(definition_toml)?;
    let storage = MobStorage::redb("./mob.redb")?;

    let handle = MobBuilder::new(definition, storage)
        .with_session_service(session_service)
        .create()
        .await?;

    handle
        .spawn(ProfileName::from("lead"), MeerkatId::from("lead-1"), None)
        .await?;
    handle
        .spawn(ProfileName::from("worker"), MeerkatId::from("worker-1"), None)
        .await?;
    handle
        .wire(MeerkatId::from("lead-1"), MeerkatId::from("worker-1"))
        .await?;
    handle
        .send_message(MeerkatId::from("lead-1"), "Coordinate work.".to_string())
        .await?;

    let run_id = handle
        .run_flow(FlowId::from("release_flow"), serde_json::json!({"severity":"critical"}))
        .await?;
    let _run = handle.flow_status(run_id).await?;
    Ok(())
}
```

### Cross-surface mob integration (`meerkat-mob-mcp`)

Mob capability for non-Rust-SDK surfaces is exposed by composing:

- `meerkat_mob_mcp::MobMcpState`
- `meerkat_mob_mcp::MobMcpDispatcher`

into:

- `SessionBuildOptions.external_tools` (`meerkat_core::service`).

```rust
use std::sync::Arc;
use meerkat_core::service::SessionBuildOptions;
use meerkat_core::AgentToolDispatcher;
use meerkat_mob::MobSessionService;
use meerkat_mob_mcp::{MobMcpDispatcher, MobMcpState};

fn with_mob_tools(session_service: Arc<dyn MobSessionService>) -> SessionBuildOptions {
    let state = Arc::new(MobMcpState::new(session_service));
    let tools: Arc<dyn AgentToolDispatcher> = Arc::new(MobMcpDispatcher::new(state));
    SessionBuildOptions {
        external_tools: Some(tools),
        ..Default::default()
    }
}
```

This is the shared mechanism used by session-driven surfaces (MCP/REST/RPC and SDKs) to provide `mob_*` tool capability.

For cross-surface behavior and examples (CLI/RPC/REST/MCP/Python/TypeScript), see [Mobs](/guides/mobs).

## SDK entry points

| Function / Type | Purpose | Detailed docs |
|-----------------|---------|---------------|
| `AgentFactory::new(store_root)` | Create a factory for building agents | [Rust SDK](/rust/overview#quick-start) |
| `AgentFactory::session_store(store)` | Override session store (e.g. BigQuery, DynamoDB) | [Rust SDK: custom stores](/rust/tools-and-stores#session-stores) |
| `build_ephemeral_service(factory, config, cap)` | Build an in-memory session service | [Rust SDK](/rust/overview#sessions) |
| `Config::load()` | Load layered config (legacy/global-project flow) | [Configuration](/concepts/configuration) |

## Structured output types

| Type | Purpose |
|------|---------|
| `OutputSchema` | Schema definition with compat/strict/format options |
| `MeerkatSchema` | Normalized JSON Schema newtype |
| `SchemaCompat` | `Lossy` (best-effort lowering) or `Strict` (reject unsupported features) |
| `SchemaFormat` | Schema format version (`MeerkatV1`) |
| `SchemaWarning` | Provider-specific compilation warning |
| `CompiledSchema` | Provider-compiled schema output |
| `SchemaError` | `InvalidRoot` or `UnsupportedFeatures` |

See the [structured output guide](/guides/structured-output) for usage details.

## Hook types

| Type | Purpose |
|------|---------|
| `HookPoint` | 8 extension points (`RunStarted` through `TurnBoundary`) |
| `HookCapability` | `Observe`, `Guardrail`, `Rewrite` |
| `HookExecutionMode` | `Foreground` (blocking) or `Background` (async) |
| `HookEntryConfig` | Per-hook configuration (id, point, priority, runtime, failure policy) |
| `HookRunOverrides` | Per-run hook customization (add entries, disable by ID) |
| `HookDecision` | `Allow` or `Deny` with reason code |
| `HookPatch` | Mutations: `LlmRequest`, `AssistantText`, `ToolArgs`, `ToolResult`, `RunResult` |
| `HookFailurePolicy` | `FailOpen` or `FailClosed` |

See the [hooks guide](/guides/hooks) for usage details.

## Skill types

| Type | Purpose |
|------|---------|
| `SkillId` | Newtype skill identifier |
| `SkillScope` | `Builtin`, `Project`, `User` |
| `SkillDescriptor` | Skill metadata (id, name, description, required capabilities) |
| `SkillDocument` | Loaded skill with body content |
| `SkillError` | `NotFound`, `CapabilityUnavailable`, `Ambiguous`, `Load`, `Parse`, `SourceUuidCollision`, `SourceUuidMutationWithoutLineage`, `MissingSkillRemaps`, `RemapWithoutLineage`, `InvalidLegacySkillRefFormat`, `UnknownSkillAlias`, `RemapCycle` |

See the [skills guide](/guides/skills) for usage details.

## Wire types (meerkat-contracts)

| Type | Purpose |
|------|---------|
| `CapabilityId` | All known capabilities (`Sessions`, `Streaming`, `Hooks`, `Shell`, etc.) |
| `CapabilityStatus` | `Available`, `DisabledByPolicy`, `NotCompiled`, `NotSupportedByProtocol` |
| `ErrorCode` | Stable error codes with projections to JSON-RPC, HTTP, and CLI exit codes |
| `WireError` | Canonical error envelope (code, message, details, capability hint) |
| `WireRunResult` | Canonical response (session_id, text, turns, tool_calls, usage, structured_output, schema_warnings) |
| `WireSessionInfo` | Session metadata |
| `WireSessionSummary` | Lightweight session summary |
| `WireEvent` | Event wire format |
| `WireUsage` | Token/cost usage breakdown |
| `ContractVersion` | Semver version (`0.3.4` currently) |
| `CoreCreateParams` | Session creation parameters |
| `StructuredOutputParams` | Schema + retry count |
| `CommsParams` | Host mode + agent name |
| `HookParams` | Hook override entries |
| `SkillsParams` | Skill enablement + references |

## Error code reference

Every `ErrorCode` maps to a stable string, JSON-RPC code, HTTP status, and CLI exit code:

| Error | Code string | JSON-RPC | HTTP | CLI |
|-------|------------|----------|------|-----|
| Session not found | `SESSION_NOT_FOUND` | -32001 | 404 | 10 |
| Session busy | `SESSION_BUSY` | -32002 | 409 | 11 |
| Session not running | `SESSION_NOT_RUNNING` | -32003 | 409 | 12 |
| Provider error | `PROVIDER_ERROR` | -32010 | 502 | 20 |
| Budget exhausted | `BUDGET_EXHAUSTED` | -32011 | 429 | 21 |
| Hook denied | `HOOK_DENIED` | -32012 | 403 | 22 |
| Agent error | `AGENT_ERROR` | -32013 | 500 | 30 |
| Capability unavailable | `CAPABILITY_UNAVAILABLE` | -32020 | 501 | 40 |
| Skill not found | `SKILL_NOT_FOUND` | -32021 | 404 | 41 |
| Skill resolution failed | `SKILL_RESOLUTION_FAILED` | -32022 | 422 | 42 |
| Invalid params | `INVALID_PARAMS` | -32602 | 400 | 2 |
| Internal error | `INTERNAL_ERROR` | -32603 | 500 | 1 |

## Provider clients

| Client | Provider | Detailed docs |
|--------|----------|---------------|
| `AnthropicClient` | Anthropic Claude | [Rust SDK: providers](/rust/advanced#providers) |
| `OpenAiClient` | OpenAI GPT | [Rust SDK: providers](/rust/advanced#providers) |
| `GeminiClient` | Google Gemini | [Rust SDK: providers](/rust/advanced#providers) |

All implement `LlmClient` and normalize responses to `LlmEvent` (text deltas, tool call deltas, usage updates, done).

`LlmError` variants: `RateLimited`, `ServerOverloaded`, `NetworkTimeout`, `ConnectionReset`, `ServerError`, `InvalidRequest`, `AuthenticationFailed`, `ContentFiltered`, `ContextLengthExceeded`, `ModelNotFound`, `InvalidApiKey`, `Unknown`. Use `error.is_retryable()` to check if an error should be retried.

## Storage implementations

| Store | Feature flag | Purpose | Detailed docs |
|-------|-------------|---------|---------------|
| `JsonlStore` | `jsonl-store` | File-based JSONL persistence | [Rust SDK: session stores](/rust/tools-and-stores#session-stores) |
| `RedbSessionStore` | `session-store` | Embedded database (redb) | [Rust SDK: session stores](/rust/tools-and-stores#session-stores) |
| `MemoryStore` | `memory-store` | In-memory (testing) | [Rust SDK: session stores](/rust/tools-and-stores#session-stores) |
| Custom (`dyn SessionStore`) | â€” | User-provided via `AgentFactory::session_store()` | [Rust SDK: custom stores](/rust/tools-and-stores#session-stores) |

## See also

- [Rust SDK reference](/rust/overview) - full API with examples
- [Architecture](/reference/architecture) - crate structure and agent loop
- [Capability matrix](/reference/capability-matrix) - build profiles and feature behavior
- [Session contracts](/reference/session-contracts) - lifecycle operational contracts
