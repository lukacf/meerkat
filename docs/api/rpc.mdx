---
title: "JSON-RPC stdio server"
description: "Stateful JSON-RPC 2.0 stdio interface for IDE integration, desktop apps, and automation tools."
icon: "terminal"
---

Meerkat exposes a JSON-RPC 2.0 stdio interface for IDE integration, desktop apps, and automation tools. Unlike REST and MCP, the RPC server keeps agents alive between turns for fast multi-turn conversations.

## Getting started

<Steps>
  <Step title="Start the server">
    ```bash
    rkat-rpc
    ```

    The server reads newline-delimited JSON (JSONL) from stdin and writes JSONL to stdout. Each line is a complete JSON-RPC 2.0 message.
  </Step>
  <Step title="Send the handshake">
    ```json
    {"jsonrpc":"2.0","id":1,"method":"initialize","params":{}}
    ```
  </Step>
  <Step title="Create a session">
    ```json
    {"jsonrpc":"2.0","id":2,"method":"session/create","params":{"prompt":"Hello!"}}
    ```
  </Step>
</Steps>

<Note>
`rkat-rpc` defaults to a new isolated realm each time. Use `--realm <id>` to share config/sessions with other surfaces or processes.
</Note>

## Runtime scope

`rkat-rpc` accepts global scope flags:

```bash
rkat-rpc [--realm <id>] [--isolated] [--instance <id>] [--realm-backend <redb|jsonl>] [--state-root <path>] [--context-root <path>] [--user-config-root <path>]
```

- `--realm`: explicit sharing/isolation key
- `--instance`: optional instance metadata
- `--realm-backend`: creation hint only; actual backend is pinned per realm manifest

## Method overview

| Method | Category | Description |
|--------|----------|-------------|
| `initialize` | Handshake | Returns server capabilities |
| `session/create` | Session | Create session and run first turn |
| `session/list` | Session | List active sessions |
| `session/read` | Session | Get session state |
| `session/archive` | Session | Remove session from runtime |
| `turn/start` | Turn | Start a new turn on existing session |
| `turn/interrupt` | Turn | Cancel in-flight turn |
| `comms/send` | Comms | Push an external event into a session |
| `comms/peers` | Comms | List discoverable peers (comms feature) |
| `comms/stream_open` | Comms | Open scoped event stream (comms feature) |
| `comms/stream_close` | Comms | Close scoped event stream (comms feature) |
| `skills/list` | Skills | List skills with provenance |
| `skills/inspect` | Skills | Inspect a skill's full content |
| `capabilities/get` | Capabilities | Runtime capability report |
| `config/get` | Config | Read current config |
| `config/set` | Config | Replace config |
| `config/patch` | Config | Merge-patch config (RFC 7396) |

<Note>
RPC uses generic session/turn methods as the control plane. Mob capability is added by composing `meerkat-mob-mcp` (`MobMcpState` + `MobMcpDispatcher`) into `SessionBuildOptions.external_tools`, which exposes `mob_*` tools to the running agent session.
</Note>

## Protocol

Standard JSON-RPC 2.0 with `"jsonrpc": "2.0"` on every message. Three message types:

- **Request** (client -> server): has `id`, `method`, `params`
- **Response** (server -> client): has `id`, `result` or `error`
- **Notification** (server -> client): has `method`, `params`, no `id`

<Accordion title="Full lifecycle diagram">
  ```text
  Client                          Server
    |                                |
    |-- initialize ----------------->|
    |<-- result { capabilities } ----|
    |-- initialized (notification) ->|
    |                                |
    |-- session/create { prompt } -->|
    |<-- session/event (notif) ------|  // AgentEvent stream
    |<-- session/event (notif) ------|
    |<-- result { session_id, ... } -|
    |                                |
    |-- turn/start { session_id } -->|
    |<-- session/event (notif) ------|
    |<-- result { text, usage } -----|
    |                                |
    |-- turn/interrupt { sid } ----->|
    |<-- result {} ------------------|
    |                                |
    |-- session/archive { sid } ---->|
    |<-- result {} ------------------|
  ```
</Accordion>

## Session methods

### initialize

Handshake. Returns server capabilities.

<CodeGroup>
```json Request
{"jsonrpc":"2.0","id":1,"method":"initialize","params":{}}
```

```json Response
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "server_info": {
      "name": "meerkat-rpc",
      "version": "0.3.4"
    },
    "contract_version": "0.3.4",
    "methods": [
      "initialize", "initialized",
      "session/create", "session/list", "session/read",
      "session/archive", "turn/start", "turn/interrupt",
      "comms/send", "comms/peers", "comms/stream_open", "comms/stream_close",
      "capabilities/get",
      "config/get", "config/set", "config/patch"
    ]
  }
}
```
</CodeGroup>

<ResponseField name="server_info.name" type="string">
  Server name.
</ResponseField>

<ResponseField name="server_info.version" type="string">
  Server version.
</ResponseField>

<ResponseField name="contract_version" type="string">
  Protocol contract version.
</ResponseField>

<ResponseField name="methods" type="array">
  List of supported method names.
</ResponseField>

### session/create

Create a new session and run the first turn.

<CodeGroup>
```json Request (minimal)
{
  "jsonrpc": "2.0",
  "id": 2,
  "method": "session/create",
  "params": {
    "prompt": "What is Rust?"
  }
}
```

```json Request (full)
{
  "jsonrpc": "2.0",
  "id": 2,
  "method": "session/create",
  "params": {
    "prompt": "What is Rust?",
    "model": "claude-sonnet-4-5",
    "provider": "anthropic",
    "max_tokens": 4096,
    "system_prompt": "You are a helpful assistant.",
    "output_schema": {
      "schema": {"type": "object", "properties": {"answer": {"type": "string"}}},
      "name": "answer"
    },
    "structured_output_retries": 2,
    "hooks_override": null,
    "enable_builtins": false,
    "enable_shell": false,
    "enable_subagents": false,
    "enable_memory": false,
    "host_mode": false,
    "comms_name": null,
    "provider_params": null,
    "preload_skills": ["extraction/email"],
    "skill_references": ["formatting/markdown"]
  }
}
```

```json Response
{
  "jsonrpc": "2.0",
  "id": 2,
  "result": {
    "session_id": "01936f8a-7b2c-7000-8000-000000000001",
    "text": "Rust is a systems programming language...",
    "turns": 1,
    "tool_calls": 0,
    "usage": {
      "input_tokens": 50,
      "output_tokens": 200,
      "total_tokens": 250
    },
    "structured_output": null,
    "schema_warnings": null
  }
}
```
</CodeGroup>

Only `prompt` is required. All other fields are optional and fall back to config defaults. During execution, `session/event` notifications are emitted (see [Notifications](#notifications)).

#### Parameter reference

<ParamField body="prompt" type="string" required>
  The user prompt to send to the agent.
</ParamField>

<ParamField body="model" type="string | null" default="claude-sonnet-4-5">
  Model name (e.g. `"claude-opus-4-6"`, `"gpt-5.2"`).
</ParamField>

<ParamField body="provider" type="string | null" default="inferred from model">
  Provider name: `"anthropic"`, `"openai"`, `"gemini"`, `"other"`.
</ParamField>

<ParamField body="max_tokens" type="u32 | null" default="config default">
  Max tokens per turn.
</ParamField>

<ParamField body="system_prompt" type="string | null" default="null">
  Override system prompt.
</ParamField>

<ParamField body="output_schema" type="object | null" default="null">
  JSON schema for structured output extraction (wrapper or raw schema).
</ParamField>

<ParamField body="structured_output_retries" type="u32" default="2">
  Max retries for structured output validation.
</ParamField>

<ParamField body="hooks_override" type="HookRunOverrides | null" default="null">
  Run-scoped hook overrides (entries to add, hook IDs to disable).
</ParamField>

<ParamField body="enable_builtins" type="bool" default="false">
  Enable built-in tools (task management, etc.).
</ParamField>

<ParamField body="enable_shell" type="bool" default="false">
  Enable shell tool (requires `enable_builtins`).
</ParamField>

<ParamField body="enable_subagents" type="bool" default="false">
  Enable sub-agent tools (fork, spawn).
</ParamField>

<ParamField body="enable_memory" type="bool" default="false">
  Enable semantic memory (`memory_search` tool + compaction indexing).
</ParamField>

<ParamField body="host_mode" type="bool" default="false">
  Run in host mode for inter-agent comms (requires `comms_name`).
</ParamField>

<ParamField body="comms_name" type="string | null" default="null">
  Agent name for inter-agent communication.
</ParamField>

<ParamField body="provider_params" type="object | null" default="null">
  Provider-specific parameters (e.g., thinking config, reasoning effort).
</ParamField>

#### Response fields

<ResponseField name="session_id" type="string">
  UUID of the created session.
</ResponseField>

<ResponseField name="text" type="string">
  The agent's response text.
</ResponseField>

<ResponseField name="turns" type="u32">
  Number of LLM calls made.
</ResponseField>

<ResponseField name="tool_calls" type="u32">
  Number of tool calls executed.
</ResponseField>

<ResponseField name="usage" type="WireUsage">
  Token usage breakdown.
</ResponseField>

<ResponseField name="structured_output" type="object | null">
  Parsed structured output.
</ResponseField>

<ResponseField name="schema_warnings" type="array | null">
  Schema compatibility warnings.
</ResponseField>

### session/list

List active sessions.

<CodeGroup>
```json Request
{"jsonrpc":"2.0","id":3,"method":"session/list"}
```

```json Response
{
  "jsonrpc": "2.0",
  "id": 3,
  "result": {
    "sessions": [
      {"session_id": "01936f8a-...", "state": "idle"},
      {"session_id": "01936f8b-...", "state": "running"}
    ]
  }
}
```
</CodeGroup>

### session/read

Get session state.

<CodeGroup>
```json Request
{"jsonrpc":"2.0","id":4,"method":"session/read","params":{"session_id":"01936f8a-..."}}
```

```json Response
{
  "jsonrpc": "2.0",
  "id": 4,
  "result": {
    "session_id": "01936f8a-...",
    "state": "idle",
    "message_count": 4,
    "total_tokens": 500
  }
}
```
</CodeGroup>

<ParamField body="session_id" type="string" required>
  Session ID to read.
</ParamField>

### session/archive

Remove a session from the runtime.

<CodeGroup>
```json Request
{"jsonrpc":"2.0","id":5,"method":"session/archive","params":{"session_id":"01936f8a-..."}}
```

```json Response
{"jsonrpc":"2.0","id":5,"result":{"archived":true}}
```
</CodeGroup>

<ParamField body="session_id" type="string" required>
  Session ID to archive.
</ParamField>

## Turn methods

### turn/start

Start a new turn on an existing session.

<CodeGroup>
```json Request
{
  "jsonrpc": "2.0",
  "id": 6,
  "method": "turn/start",
  "params": {
    "session_id": "01936f8a-...",
    "prompt": "Can you explain ownership?",
    "skill_references": ["rust-patterns/ownership"]
  }
}
```

```json Response
{
  "jsonrpc": "2.0",
  "id": 6,
  "result": {
    "session_id": "01936f8a-...",
    "text": "Ownership is Rust's approach to memory management...",
    "turns": 1,
    "tool_calls": 0,
    "usage": {
      "input_tokens": 300,
      "output_tokens": 400,
      "total_tokens": 700
    },
    "structured_output": null,
    "schema_warnings": null
  }
}
```
</CodeGroup>

Returns the same result shape as `session/create`. Fails with error code `-32001` (SESSION_BUSY) if a turn is already in progress.

<ParamField body="session_id" type="string" required>
  Session ID to continue.
</ParamField>

<ParamField body="prompt" type="string" required>
  The follow-up prompt.
</ParamField>

### turn/interrupt

Cancel an in-flight turn. No-op if the session is idle.

<CodeGroup>
```json Request
{"jsonrpc":"2.0","id":7,"method":"turn/interrupt","params":{"session_id":"01936f8a-..."}}
```

```json Response
{"jsonrpc":"2.0","id":7,"result":{"interrupted":true}}
```
</CodeGroup>

<ParamField body="session_id" type="string" required>
  Session ID to interrupt.
</ParamField>

## Event methods

### comms/send

Push an external event into a running session's inbox. The event is queued and processed at the next turn boundary.

<CodeGroup>
```json Request
{
  "jsonrpc": "2.0",
  "id": 8,
  "method": "comms/send",
  "params": {
    "session_id": "01936f8a-...",
    "payload": {"alert": "build failed", "repo": "main"},
    "source": "ci-pipeline"
  }
}
```

```json Response
{
  "jsonrpc": "2.0",
  "id": 8,
  "result": {"queued": true}
}
```
</CodeGroup>

<ParamField body="session_id" type="string" required>
  Session ID to push the event to.
</ParamField>

<ParamField body="payload" type="any JSON" required>
  Any JSON value. Serialized and injected as event body.
</ParamField>

<ParamField body="source" type="string">
  Optional source label. Prepended as `[source: ci-pipeline]` metadata in the event body.
</ParamField>

Error `-32603` if inbox full, `-32602` if session not found or invalid session ID.

### comms/peers

List discoverable peers from configured `TrustedPeers` and active in-process registrations. Requires the `comms` feature.

<CodeGroup>
```json Request
{
  "jsonrpc": "2.0",
  "id": 9,
  "method": "comms/peers",
  "params": {
    "session_id": "01936f8a-..."
  }
}
```

```json Response
{
  "jsonrpc": "2.0",
  "id": 9,
  "result": {
    "peers": [
      {"name": "reviewer", "address": "127.0.0.1:4201"},
      {"name": "coordinator", "address": "inproc"}
    ]
  }
}
```
</CodeGroup>

<ParamField body="session_id" type="string" required>
  Session ID to query peers for.
</ParamField>

### comms/stream_open

Open a scoped event stream for a session. Events from this session will be emitted as `comms/stream_event` notifications. Requires the `comms` feature.

<CodeGroup>
```json Request
{
  "jsonrpc": "2.0",
  "id": 10,
  "method": "comms/stream_open",
  "params": {
    "session_id": "01936f8a-...",
    "scope": "session",
    "interaction_id": null
  }
}
```

```json Response
{"jsonrpc":"2.0","id":10,"result":{"stream_id":"550e8400-e29b-41d4-a716-446655440000","opened":true}}
```
</CodeGroup>

<ParamField body="session_id" type="string" required>
  Session ID to stream events for.
</ParamField>

<ParamField body="scope" type="string" required>
  Stream scope: `"session"` (all events for the session) or `"interaction"` (events for a specific interaction).
</ParamField>

<ParamField body="interaction_id" type="string | null" default="null">
  Interaction UUID (required when `scope` is `"interaction"`).
</ParamField>

### comms/stream_close

Close a previously opened scoped event stream. Requires the `comms` feature.

<CodeGroup>
```json Request
{
  "jsonrpc": "2.0",
  "id": 11,
  "method": "comms/stream_close",
  "params": {
    "stream_id": "550e8400-e29b-41d4-a716-446655440000"
  }
}
```

```json Response
{"jsonrpc":"2.0","id":11,"result":{"stream_id":"550e8400-e29b-41d4-a716-446655440000","closed":true}}
```
</CodeGroup>

<ParamField body="stream_id" type="string" required>
  Stream ID returned by `comms/stream_open`.
</ParamField>

## Skills methods

### skills/list

List all skills with provenance information, including active and shadowed entries.

<CodeGroup>
```json Request
{"jsonrpc":"2.0","id":12,"method":"skills/list"}
```

```json Response
{
  "jsonrpc": "2.0",
  "id": 12,
  "result": {
    "skills": [
      {
        "id": "task-workflow",
        "name": "Task Workflow",
        "description": "How to use task tools",
        "scope": "builtin",
        "source": "embedded",
        "is_active": true
      },
      {
        "id": "my-deployment",
        "name": "Deployment Guide",
        "description": "Project-specific deployment",
        "scope": "project",
        "source": "project",
        "is_active": true
      },
      {
        "id": "task-workflow",
        "name": "Custom Task Workflow",
        "description": "Override tasks",
        "scope": "project",
        "source": "company",
        "is_active": false,
        "shadowed_by": "embedded"
      }
    ]
  }
}
```
</CodeGroup>

<ResponseField name="skills" type="array">
  List of `SkillEntry` objects with `id`, `name`, `description`, `scope`, `source`, `is_active`, and optional `shadowed_by`.
</ResponseField>

Returns error `-32603` if skills are not enabled.

### skills/inspect

Inspect a skill's full content (body).

<CodeGroup>
```json Request
{
  "jsonrpc": "2.0",
  "id": 13,
  "method": "skills/inspect",
  "params": {
    "id": "task-workflow",
    "source": null
  }
}
```

```json Response
{
  "jsonrpc": "2.0",
  "id": 13,
  "result": {
    "id": "task-workflow",
    "name": "Task Workflow",
    "description": "How to use task tools",
    "scope": "builtin",
    "source": "embedded",
    "body": "# Task Workflow\n\nUse task_create to..."
  }
}
```
</CodeGroup>

<ParamField body="id" type="string" required>
  Skill ID to inspect (e.g. `"task-workflow"`, `"extraction/email"`).
</ParamField>

<ParamField body="source" type="string | null" default="null">
  Load from a specific named source, bypassing first-wins resolution. Useful for inspecting shadowed skills.
</ParamField>

## Capabilities

### capabilities/get

Return runtime capabilities with status resolved against config. This lists every capability known to Meerkat with its current status (available, disabled by policy, not compiled, etc.).

<CodeGroup>
```json Request
{"jsonrpc":"2.0","id":8,"method":"capabilities/get"}
```

```json Response
{
  "jsonrpc": "2.0",
  "id": 8,
  "result": {
    "contract_version": {"major": 0, "minor": 2, "patch": 0},
    "capabilities": [
      {
        "id": "sessions",
        "description": "Session lifecycle management",
        "status": "Available"
      },
      {
        "id": "structured_output",
        "description": "Structured output extraction with JSON schema",
        "status": "Available"
      },
      {
        "id": "hooks",
        "description": "Lifecycle hooks for tool and turn events",
        "status": "Available"
      },
      {
        "id": "builtins",
        "description": "Built-in tools (task management)",
        "status": {"DisabledByPolicy": {"description": "Disabled by config"}}
      },
      {
        "id": "shell",
        "description": "Shell command execution",
        "status": {"DisabledByPolicy": {"description": "Disabled by config"}}
      },
      {
        "id": "comms",
        "description": "Inter-agent communication",
        "status": {"NotCompiled": {"feature": "comms"}}
      },
      {
        "id": "sub_agents",
        "description": "Sub-agent forking and spawning",
        "status": "Available"
      },
      {
        "id": "memory_store",
        "description": "Semantic memory indexing",
        "status": "Available"
      },
      {
        "id": "skills",
        "description": "Skill loading and injection",
        "status": "Available"
      }
    ]
  }
}
```
</CodeGroup>

Possible `status` values:

| Status | Shape | Meaning |
|--------|-------|---------|
| `Available` | `"Available"` | Compiled in, config-enabled, protocol supports it |
| `DisabledByPolicy` | `{"DisabledByPolicy": {"description": "..."}}` | Compiled in but disabled by policy |
| `NotCompiled` | `{"NotCompiled": {"feature": "..."}}` | Feature flag absent at compile time |
| `NotSupportedByProtocol` | `{"NotSupportedByProtocol": {"reason": "..."}}` | This protocol surface does not support it |

## Config methods

### config/get

Read current realm config envelope.

<CodeGroup>
```json Request
{"jsonrpc":"2.0","id":9,"method":"config/get"}
```

```json Response
{
  "jsonrpc": "2.0",
  "id": 9,
  "result": {
    "config": {
      "agent": {
        "model": "claude-sonnet-4-5",
        "max_tokens_per_turn": 8192
      }
    },
    "generation": 3,
    "realm_id": "team-alpha",
    "instance_id": "rpc-worker-1",
    "backend": "redb",
    "resolved_paths": {
      "root": "/.../meerkat/realms/team-alpha",
      "manifest_path": "/.../realm_manifest.json",
      "config_path": "/.../config.toml",
      "sessions_redb_path": "/.../sessions.redb",
      "sessions_jsonl_dir": "/.../sessions_jsonl"
    }
  }
}
```
</CodeGroup>

### config/set

Replace config, optionally using generation CAS.

<CodeGroup>
```json Request
{
  "jsonrpc":"2.0",
  "id":10,
  "method":"config/set",
  "params":{
    "config": {"agent":{"model":"gpt-5.2"}},
    "expected_generation": 3
  }
}
```

```json Response
{
  "jsonrpc":"2.0",
  "id":10,
  "result": {
    "config": {"agent":{"model":"gpt-5.2"}},
    "generation": 4,
    "realm_id": "team-alpha",
    "instance_id": null,
    "backend": "redb",
    "resolved_paths": { "...": "..." }
  }
}
```
</CodeGroup>

### config/patch

Merge-patch the config (RFC 7396).

<CodeGroup>
```json Request
{
  "jsonrpc":"2.0",
  "id":11,
  "method":"config/patch",
  "params":{
    "patch":{"agent":{"max_tokens_per_turn":8192}},
    "expected_generation": 4
  }
}
```

```json Response
{
  "jsonrpc":"2.0",
  "id":11,
  "result": {
    "config": {"agent":{"max_tokens_per_turn":8192}},
    "generation": 5,
    "realm_id": "team-alpha",
    "instance_id": null,
    "backend": "redb",
    "resolved_paths": { "...": "..." }
  }
}
```
</CodeGroup>

<Note>
`config/set` also accepts a direct config object as params for compatibility. In that mode, no CAS check is applied.
</Note>

## Notifications

During turn execution, the server emits `session/event` notifications containing serialized `AgentEvent` payloads:

```json
{
  "jsonrpc": "2.0",
  "method": "session/event",
  "params": {
    "session_id": "01936f8a-...",
    "event": {
      "type": "text_delta",
      "delta": "Rust is"
    }
  }
}
```

Event types match the `AgentEvent` enum in `meerkat-core`:

| Event | Description |
|-------|-------------|
| `run_started` | Agent execution began |
| `run_completed` | Agent run finished |
| `run_failed` | Agent run failed |
| `turn_started` | New LLM call within the turn |
| `text_delta` | Streaming text chunk from LLM |
| `text_complete` | Full text for this turn |
| `tool_call_requested` | LLM wants to call a tool |
| `tool_result_received` | Tool result processed |
| `turn_completed` | LLM call finished |
| `tool_execution_started` | Tool dispatch began |
| `tool_execution_completed` | Tool returned a result |
| `tool_execution_timed_out` | Tool exceeded timeout |
| `compaction_started` | Context compaction began |
| `compaction_completed` | Compaction finished |
| `compaction_failed` | Compaction failed |
| `budget_warning` | Approaching resource limits |
| `retrying` | Retrying after transient error |
| `hook_started` | Hook execution began |
| `hook_completed` | Hook finished |
| `hook_failed` | Hook execution failed |
| `hook_denied` | Hook blocked operation |
| `hook_rewrite_applied` | Hook rewrote content |
| `hook_patch_published` | Hook published a patch |
| `skills_resolved` | Skills loaded for turn |
| `skill_resolution_failed` | Skill resolution failed |
| `interaction_complete` | Interaction-scoped stream completed |
| `interaction_failed` | Interaction-scoped stream failed |
| `stream_truncated` | Backpressure dropped intermediate events |

### comms/stream_event notifications

When a scoped event stream is open (via `comms/stream_open`), the server emits `comms/stream_event` notifications:

```json
{
  "jsonrpc": "2.0",
  "method": "comms/stream_event",
  "params": {
    "stream_id": "550e8400-e29b-41d4-a716-446655440000",
    "scope": {"type": "session", "session_id": "01936f8a-..."},
    "sequence": 1,
    "event": {
      "type": "text_delta",
      "delta": "Hello"
    },
    "contract_version": "0.3.4"
  }
}
```

These events are scoped to the stream and only emitted while the stream is open.

## Error codes

Standard JSON-RPC codes plus Meerkat-specific application codes:

| Code | Name | Description |
|------|------|-------------|
| -32700 | Parse error | Invalid JSON |
| -32600 | Invalid request | Not a valid JSON-RPC request |
| -32601 | Method not found | Unknown method |
| -32602 | Invalid params | Missing or invalid parameters |
| -32603 | Internal error | Server error |
| -32001 | Session not found | Session ID does not exist |
| -32002 | Session busy | Turn already in progress |
| -32003 | Session not running | Session not in running state |
| -32010 | Provider error | LLM provider issue (missing key, auth) |
| -32011 | Budget exhausted | Resource limits reached |
| -32012 | Hook denied | Hook blocked the operation |
| -32013 | Agent error | Internal agent error |
| -32020 | Capability unavailable | Required capability not available |
| -32021 | Skill not found | Requested skill does not exist |
| -32022 | Skill resolution failed | Skill resolution error |

## Architecture

The RPC server is **stateful**: agents stay alive between turns. This is the key difference from REST (stateless per-request) and MCP (callback pattern).

```text
Client (IDE, app) <--stdio JSONL--> RpcServer
                                       |
                                  MethodRouter
                                       |
                                  SessionRuntime
                                   /    |    \
                            Session  Session  Session
                             Task    Task     Task
                              |       |        |
                            Agent   Agent    Agent
                         (exclusive ownership)
```

Each session gets a dedicated tokio task that exclusively owns the `Agent`. This solves the `cancel(&mut self)` requirement without mutex. Commands (`StartTurn`, `Interrupt`, `Shutdown`) are sent via channels.

<Note>
**Backpressure:** The notification channel is bounded. When the client reads slowly, the agent naturally slows down.
</Note>

## Comparison with other surfaces

| | CLI | REST | MCP | RPC |
|---|---|---|---|---|
| Stateful | No | No | No | **Yes** |
| Streaming | stderr | SSE | Optional | JSONL notifications |
| Multi-session | No | No | No | **Yes** |
| Cancellation | Ctrl+C | N/A | N/A | `turn/interrupt` |
| Bidirectional | No | No (SSE one-way) | Partial | **Yes** |

## See also

- [CLI reference](/cli/commands)
- [REST API](/api/rest)
- [MCP](/api/mcp)
- [Architecture](/reference/architecture)
