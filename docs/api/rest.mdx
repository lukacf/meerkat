---
title: "REST API"
description: "HTTP server for running and managing agent sessions over REST endpoints."
icon: "globe"
---

Meerkat ships a REST server for running and managing agent sessions over HTTP. This is the best fit if you want a simple, language-agnostic API for the Meerkat core.

## Getting started

<Steps>
  <Step title="Build the server">
    <CodeGroup>
    ```bash Development
    cargo run --package meerkat-rest -- --realm team-alpha
    ```

    ```bash Production
    cargo build --release --package meerkat-rest
    ./target/release/rkat-rest --realm team-alpha
    ```
    </CodeGroup>
  </Step>
  <Step title="Set API keys">
    Export the key for your chosen provider:

    ```bash
    export ANTHROPIC_API_KEY="sk-..."
    # or OPENAI_API_KEY, GOOGLE_API_KEY
    ```
  </Step>
  <Step title="Send a request">
    ```bash
    curl -X POST http://127.0.0.1:8080/sessions \
      -H "Content-Type: application/json" \
      -d '{"prompt": "Hello, Meerkat!"}'
    ```
  </Step>
</Steps>

## Runtime scope

`rkat-rest` accepts:

- `--realm <id>`
- `--instance <id>`
- `--realm-backend <redb|jsonl>`

If `--realm` is omitted, the server creates a new isolated opaque realm (`realm-...`).

## Endpoint overview

| Method | Path | Description |
|--------|------|-------------|
| `POST` | `/sessions` | Create and run a new session |
| `POST` | `/sessions/{id}/messages` | Continue an existing session |
| `POST` | `/sessions/{id}/event` | Push an external event into a session |
| `GET` | `/sessions/{id}` | Fetch session metadata and usage |
| `GET` | `/sessions/{id}/events` | SSE stream for real-time updates |
| `POST` | `/comms/send` | Push comms message into a session (comms feature) |
| `GET` | `/comms/peers` | List discoverable peers (comms feature) |
| `GET` | `/health` | Liveness check |
| `GET` | `/capabilities` | Runtime capabilities |
| `GET` | `/config` | Read config |
| `PUT` | `/config` | Replace config |
| `PATCH` | `/config` | Merge-patch config (RFC 7396) |

## Configuration

<Accordion title="Server configuration details">
  REST configuration is realm-scoped:

  - macOS: `~/Library/Application Support/meerkat/rest/realms/<realm>/config.toml`
  - Linux: `~/.local/share/meerkat/rest/realms/<realm>/config.toml`
  - Windows: `%APPDATA%\\meerkat\\rest\\realms\\<realm>\\config.toml`

  Each realm also has `realm_manifest.json` (backend pinning) and `config_state.json` (generation CAS state).

  Key sections:

  ```toml
  [rest]
  host = "127.0.0.1"
  port = 8080

  [agent]
  model = "claude-opus-4-6"
  max_tokens_per_turn = 8192

  [tools]
  builtins_enabled = false
  shell_enabled = false
  ```

  API keys are provided via environment variables:

  - `ANTHROPIC_API_KEY`
  - `OPENAI_API_KEY`
  - `GOOGLE_API_KEY`
</Accordion>

## Endpoints

### POST /sessions

Create and run a new session.

<CodeGroup>
```json Request (minimal)
{
  "prompt": "Your prompt here"
}
```

```json Request (full)
{
  "prompt": "Your prompt here",
  "system_prompt": "Optional system prompt",
  "model": "claude-opus-4-6",
  "provider": "anthropic",
  "max_tokens": 4096,
  "output_schema": {
    "schema": {"type": "object", "properties": {"answer": {"type": "string"}}},
    "name": "answer",
    "strict": false,
    "compat": "lossy",
    "format": "meerkat_v1"
  },
  "structured_output_retries": 2,
  "verbose": false,
  "host_mode": false,
  "comms_name": null,
  "hooks_override": null
}
```

```json Response
{
  "session_id": "01936f8a-7b2c-7000-8000-000000000001",
  "text": "Response text",
  "turns": 1,
  "tool_calls": 0,
  "usage": {
    "input_tokens": 50,
    "output_tokens": 200,
    "total_tokens": 250
  },
  "structured_output": null,
  "schema_warnings": null
}
```
</CodeGroup>

#### Request fields

<ParamField body="prompt" type="string" required>
  The user prompt to send to the agent.
</ParamField>

<ParamField body="system_prompt" type="string | null" default="null">
  Override the system prompt for this session.
</ParamField>

<ParamField body="model" type="string | null" default="config default">
  Model name (e.g. `"claude-opus-4-6"`, `"gpt-5.2"`).
</ParamField>

<ParamField body="provider" type="string | null" default="inferred from model">
  Provider: `"anthropic"`, `"openai"`, `"gemini"`, `"other"`.
</ParamField>

<ParamField body="max_tokens" type="u32 | null" default="config default">
  Max tokens per turn.
</ParamField>

<ParamField body="output_schema" type="OutputSchema | null" default="null">
  JSON schema for structured output extraction (wrapper or raw schema).
</ParamField>

<ParamField body="structured_output_retries" type="u32" default="2">
  Max retries for structured output validation.
</ParamField>

<ParamField body="verbose" type="bool" default="false">
  Enable verbose event logging (server-side).
</ParamField>

<ParamField body="host_mode" type="bool" default="false">
  Run in host mode for inter-agent comms (requires `comms_name`).
</ParamField>

<ParamField body="comms_name" type="string | null" default="null">
  Agent name for inter-agent communication.
</ParamField>

<ParamField body="hooks_override" type="HookRunOverrides | null" default="null">
  Run-scoped hook overrides (see [Hooks](/guides/hooks)).
</ParamField>

#### Response fields

<ResponseField name="session_id" type="string">
  UUID of the created session.
</ResponseField>

<ResponseField name="text" type="string">
  The agent's response text.
</ResponseField>

<ResponseField name="turns" type="u32">
  Number of LLM calls made.
</ResponseField>

<ResponseField name="tool_calls" type="u32">
  Number of tool calls executed.
</ResponseField>

<ResponseField name="usage" type="WireUsage">
  Token usage breakdown.
</ResponseField>

<ResponseField name="usage.input_tokens" type="u64">
  Input tokens consumed.
</ResponseField>

<ResponseField name="usage.output_tokens" type="u64">
  Output tokens generated.
</ResponseField>

<ResponseField name="usage.total_tokens" type="u64">
  Total tokens (input + output).
</ResponseField>

<ResponseField name="usage.cache_creation_tokens" type="u64 | null">
  Cache creation tokens (provider-specific).
</ResponseField>

<ResponseField name="usage.cache_read_tokens" type="u64 | null">
  Cache read tokens (provider-specific).
</ResponseField>

<ResponseField name="structured_output" type="object | null">
  Parsed structured output (when `output_schema` was provided).
</ResponseField>

<ResponseField name="schema_warnings" type="array | null">
  Schema compatibility warnings per provider.
</ResponseField>

<Accordion title="Structured output example">
  <CodeGroup>
  ```json Request
  {
    "prompt": "Extract the capital of France",
    "model": "claude-opus-4-6",
    "output_schema": {
      "schema": {
        "type": "object",
        "properties": {
          "country": {"type": "string"},
          "capital": {"type": "string"}
        },
        "required": ["country", "capital"]
      },
      "name": "capital_extraction",
      "strict": false,
      "compat": "lossy",
      "format": "meerkat_v1"
    },
    "structured_output_retries": 2
  }
  ```

  ```json Response
  {
    "session_id": "01936f8a-7b2c-7000-8000-000000000002",
    "text": "{\"country\":\"France\",\"capital\":\"Paris\"}",
    "turns": 1,
    "tool_calls": 0,
    "usage": {
      "input_tokens": 80,
      "output_tokens": 30,
      "total_tokens": 110
    },
    "structured_output": {
      "country": "France",
      "capital": "Paris"
    },
    "schema_warnings": [
      {
        "provider": "gemini",
        "path": "/properties/choice/oneOf",
        "message": "Removed unsupported keyword 'oneOf'"
      }
    ]
  }
  ```
  </CodeGroup>

  When `output_schema` is provided, the `text` field contains the schema-only JSON
  string produced by the extraction turn (no extra prose). The `structured_output`
  field contains the parsed JSON value for convenience.

  `output_schema` may be provided as a wrapper object (shown above) or as a raw
  JSON Schema object. The wrapper enables explicit `compat`/`format` settings.
</Accordion>

### POST /sessions/\{id\}/messages

Continue an existing session.

<CodeGroup>
```json Request
{
  "session_id": "01936f8a-7b2c-7000-8000-000000000001",
  "prompt": "Follow-up message"
}
```

```json Response
{
  "session_id": "01936f8a-7b2c-7000-8000-000000000001",
  "text": "Response to follow-up",
  "turns": 1,
  "tool_calls": 0,
  "usage": {
    "input_tokens": 100,
    "output_tokens": 150,
    "total_tokens": 250
  },
  "structured_output": null,
  "schema_warnings": null
}
```
</CodeGroup>

#### Request fields

<ParamField body="session_id" type="string" required>
  Session ID (must match the path `{id}`).
</ParamField>

<ParamField body="prompt" type="string" required>
  Follow-up prompt.
</ParamField>

<ParamField body="system_prompt" type="string | null" default="null">
  Override the system prompt.
</ParamField>

<ParamField body="model" type="string | null" default="from session">
  Model override for this turn.
</ParamField>

<ParamField body="provider" type="string | null" default="from session">
  Provider override for this turn.
</ParamField>

<ParamField body="max_tokens" type="u32 | null" default="from session">
  Max tokens override for this turn.
</ParamField>

<ParamField body="output_schema" type="OutputSchema | null" default="null">
  Structured output schema for this turn.
</ParamField>

<ParamField body="structured_output_retries" type="u32" default="2">
  Max retries for structured output validation.
</ParamField>

<ParamField body="verbose" type="bool" default="false">
  Enable verbose event logging.
</ParamField>

<ParamField body="host_mode" type="bool" default="false">
  Enable host mode for this turn.
</ParamField>

<ParamField body="comms_name" type="string | null" default="from session">
  Agent name for comms.
</ParamField>

<ParamField body="hooks_override" type="HookRunOverrides | null" default="null">
  Run-scoped hook overrides.
</ParamField>

#### Response fields

Same shape as `POST /sessions`.

### POST /sessions/\{id\}/event

Push an external event into a running session's inbox. The event is queued and processed at the next turn boundary.

<CodeGroup>
```bash Without auth (localhost only)
curl -X POST http://localhost:8080/sessions/sid_abc/event \
  -H "Content-Type: application/json" \
  -d '{"alert": "CPU spike", "host": "web-03"}'
```

```bash With webhook secret
curl -X POST http://localhost:8080/sessions/sid_abc/event \
  -H "Content-Type: application/json" \
  -H "X-Webhook-Secret: my-secret" \
  -d '{"alert": "deployment failed"}'
```

```json Response (202 Accepted)
{"queued": true}
```
</CodeGroup>

<ParamField body="(body)" type="any JSON" required>
  Any JSON payload. Pretty-printed and injected as an event into the agent's inbox.
</ParamField>

<ParamField header="X-Webhook-Secret" type="string">
  Webhook secret for authentication. Required when `RKAT_WEBHOOK_SECRET` env var is set on the server. Compared using constant-time equality (`subtle::ConstantTimeEq`).
</ParamField>

| HTTP Status | When |
|-------------|------|
| 202 | Event queued successfully |
| 404 | Session not found |
| 401 | Missing or invalid webhook secret |
| 503 | Event inbox is full |

### GET /sessions/\{id\}

Fetch session metadata and usage.

```json Response
{
  "session_id": "01936f8a-7b2c-7000-8000-000000000001",
  "created_at": "2025-01-15T10:30:00Z",
  "updated_at": "2025-01-15T10:31:00Z",
  "message_count": 4,
  "total_tokens": 500
}
```

### GET /sessions/\{id\}/events

Server-Sent Events (SSE) stream for real-time updates.

Event types:

| Event | Description |
|-------|-------------|
| `session_loaded` | Emitted on connect with session metadata |
| `run_started` | Agent execution began |
| `run_completed` | Agent run finished |
| `run_failed` | Agent run failed |
| `turn_started` | New LLM call within the turn |
| `text_delta` | Streaming text chunk from LLM |
| `text_complete` | Full text for this turn |
| `tool_call_requested` | LLM wants to call a tool |
| `tool_result_received` | Tool result processed |
| `turn_completed` | LLM call finished |
| `tool_execution_started` | Tool dispatch began |
| `tool_execution_completed` | Tool returned a result |
| `tool_execution_timed_out` | Tool exceeded timeout |
| `compaction_started` | Context compaction began |
| `compaction_completed` | Compaction finished |
| `compaction_failed` | Compaction failed |
| `budget_warning` | Approaching resource limits |
| `retrying` | Retrying after transient error |
| `hook_started` | Hook execution began |
| `hook_completed` | Hook finished |
| `hook_failed` | Hook execution failed |
| `hook_denied` | Hook blocked operation |
| `skills_resolved` | Skills loaded for turn |
| `skill_resolution_failed` | Skill resolution failed |
| `done` | Emitted when the broadcast channel closes |

### GET /health

Returns `"ok"` (HTTP 200). Use for liveness checks.

### GET /capabilities

Returns runtime capabilities with status resolved against config.

```json Response (abbreviated)
{
  "contract_version": {"major": 0, "minor": 2, "patch": 0},
  "capabilities": [
    {
      "id": "sessions",
      "description": "Session lifecycle management",
      "status": "Available"
    },
    {
      "id": "shell",
      "description": "Shell command execution",
      "status": {"DisabledByPolicy": {"description": "Disabled by config"}}
    }
  ]
}
```

The full response includes all capabilities: `sessions`, `streaming`, `structured_output`, `hooks`, `builtins`, `shell`, `comms`, `sub_agents`, `memory_store`, `skills`. See the [RPC capabilities endpoint](/api/rpc#capabilitiesget) for the complete example.

### GET /config

Returns a realm config envelope:

- `config`
- `generation`
- `realm_id`
- `instance_id`
- `backend`
- `resolved_paths`

### PUT /config

Replaces config.

Accepted request forms:

- Direct config object (compat)
- Wrapped form with CAS:
  - `{ "config": <Config>, "expected_generation": <u64|null> }`

### PATCH /config

Applies RFC 7396 merge patch.

Accepted request forms:

- Direct patch object (compat)
- Wrapped form with CAS:
  - `{ "patch": <JSON>, "expected_generation": <u64|null> }`

If `expected_generation` is stale, the server returns `400` with a generation-conflict message.

### POST /comms/send

Push a comms message into a running session. Requires the `comms` feature.

<CodeGroup>
```json Request
{
  "session_id": "01936f8a-7b2c-7000-8000-000000000001",
  "payload": {"alert": "build failed", "repo": "main"},
  "source": "ci-pipeline"
}
```

```json Response (202 Accepted)
{"queued": true}
```
</CodeGroup>

<ParamField body="session_id" type="string" required>
  Session ID to push the event to.
</ParamField>

<ParamField body="payload" type="any JSON" required>
  Any JSON value. Serialized and injected as event body.
</ParamField>

<ParamField body="source" type="string">
  Optional source label.
</ParamField>

<Note>
Unlike `POST /sessions/{id}/event` (which uses `RKAT_WEBHOOK_SECRET` header auth),
`/comms/send` has **no authentication**. It is intended for trusted internal callers
that already know the session ID.
</Note>

### GET /comms/peers

List discoverable peers. Requires the `comms` feature.

```json Response
{
  "peers": [
    {"name": "reviewer", "address": "127.0.0.1:4201"},
    {"name": "coordinator", "address": "inproc"}
  ]
}
```

## Error responses

All errors are returned as JSON with an HTTP status code:

```json
{
  "error": "Human-readable error message",
  "code": "ERROR_CODE"
}
```

| HTTP Status | Code | When |
|-------------|------|------|
| 400 | `INVALID_PARAMS` | Invalid parameters, session ID mismatch, host_mode without comms |
| 403 | `HOOK_DENIED` | Hook blocked the operation |
| 404 | `SESSION_NOT_FOUND` | Session does not exist |
| 404 | `SKILL_NOT_FOUND` | Requested skill does not exist |
| 409 | `SESSION_BUSY` | Turn already in progress |
| 409 | `SESSION_NOT_RUNNING` | Session not in running state |
| 422 | `SKILL_RESOLUTION_FAILED` | Skill resolution error |
| 429 | `BUDGET_EXHAUSTED` | Resource limits reached |
| 500 | `AGENT_ERROR` | LLM provider error, tool dispatch failure, agent loop error |
| 500 | `INTERNAL_ERROR` | Store initialization failure, unexpected server error |
| 501 | `CAPABILITY_UNAVAILABLE` | Required capability not compiled in or disabled |
| 502 | `PROVIDER_ERROR` | LLM provider issue (missing key, auth failure) |

<CodeGroup>
```json Session not found
{
  "error": "Session not found: 01936f8a-7b2c-7000-8000-000000000099",
  "code": "SESSION_NOT_FOUND"
}
```

```json Bad request
{
  "error": "Session ID mismatch: path=abc body=def",
  "code": "INVALID_PARAMS"
}
```
</CodeGroup>

## Notes

<Note>
Host mode requires `host_mode: true` and a `comms_name`. If `host_mode` is
requested but the binary was not compiled with comms support, the server
returns a `BAD_REQUEST` error.
</Note>

<Note>
`hooks_override` allows per-request hook overrides including adding extra hook
entries and disabling specific hooks by ID. See [Hooks](/guides/hooks) for the
`HookRunOverrides` schema.
</Note>
