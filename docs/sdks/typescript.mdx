---
title: "TypeScript SDK"
description: "TypeScript client for the Meerkat agent runtime, communicating over JSON-RPC with rkat."
icon: "js"
---

The TypeScript SDK (`@meerkat/sdk`) lets you manage sessions, run agent turns, stream events, and query capabilities from TypeScript or JavaScript. It communicates with a local `rkat rpc` subprocess over JSON-RPC 2.0.

## Getting started

<Steps>
  <Step title="Install the SDK">
    ```bash
    npm install @meerkat/sdk
    ```
  </Step>
  <Step title="Install the rkat binary">
    Build from the Meerkat repo:

    ```bash
    cargo build -p meerkat-cli --release
    # Ensure target/release/rkat is on your $PATH
    ```

    You also need an API key for at least one LLM provider set in your environment (e.g. `ANTHROPIC_API_KEY`, `OPENAI_API_KEY`, or `GOOGLE_API_KEY`).
  </Step>
  <Step title="Configure tsconfig">
    The SDK is published as ESM. Your `tsconfig.json` must use Node16 module resolution:

    ```json
    {
      "compilerOptions": {
        "target": "ES2022",
        "module": "Node16",
        "moduleResolution": "Node16",
        "lib": ["ES2022"],
        "strict": true,
        "esModuleInterop": true
      }
    }
    ```
  </Step>
  <Step title="Connect and run">
    ```typescript
    import { MeerkatClient } from "@meerkat/sdk";

    const client = new MeerkatClient();
    await client.connect();

    const result = await client.createSession({
      prompt: "What is the capital of Sweden?",
    });

    console.log(result.text);         // "Stockholm..."
    console.log(result.session_id);   // UUID of the new session
    console.log(result.usage);        // { input_tokens, output_tokens, total_tokens, ... }

    // Multi-turn: send a follow-up in the same session.
    const followUp = await client.startTurn(
      result.session_id,
      "And what is its population?",
    );
    console.log(followUp.text);

    await client.archiveSession(result.session_id);
    await client.close();
    ```
  </Step>
</Steps>

---

## Method overview

| Method | Description |
|--------|-------------|
| `connect()` | Spawn `rkat rpc`, handshake, fetch capabilities |
| `close()` | Kill the subprocess |
| `createSession(params)` | Create a session and run the first turn |
| `startTurn(sessionId, prompt)` | Continue an existing session |
| `interrupt(sessionId)` | Cancel an in-flight turn |
| `listSessions()` | List active sessions |
| `readSession(sessionId)` | Read session state |
| `archiveSession(sessionId)` | Remove a session |
| `getCapabilities()` | Get runtime capabilities |
| `hasCapability(id)` | Check if a capability is available |
| `requireCapability(id)` | Guard a code path by capability |
| `getConfig()` | Read runtime configuration |
| `setConfig(config)` | Replace runtime configuration |
| `patchConfig(patch)` | Merge-patch runtime configuration |

---

## MeerkatClient

### Constructor

```typescript
new MeerkatClient(rkatPath?: string)
```

<ParamField path="rkatPath" type="string" default="rkat">
  Path to the `rkat` binary. Override if it is not on your `$PATH`.
</ParamField>

### connect()

```typescript
async connect(): Promise<this>
```

Spawns `rkat rpc` as a child process, performs the `initialize` handshake, checks contract version compatibility, and fetches runtime capabilities via `capabilities/get`. Returns `this` for chaining.

Throws `MeerkatError` with code `"VERSION_MISMATCH"` if the server's contract version is incompatible with the SDK's `CONTRACT_VERSION`.

### close()

```typescript
async close(): Promise<void>
```

Kills the `rkat rpc` subprocess and cleans up resources.

### createSession(params)

```typescript
async createSession(params: {
  prompt: string;
  model?: string;
  provider?: string;
  system_prompt?: string;
  max_tokens?: number;
  output_schema?: Record<string, unknown>;
  structured_output_retries?: number;
  hooks_override?: Record<string, unknown>;
  enable_builtins?: boolean;
  enable_shell?: boolean;
  enable_subagents?: boolean;
  enable_memory?: boolean;
  host_mode?: boolean;
  comms_name?: string;
  provider_params?: Record<string, unknown>;
}): Promise<WireRunResult>
```

Creates a new session and immediately runs the first turn with the given prompt. Returns a `WireRunResult`.

<ParamField path="prompt" type="string" required>
  The user prompt for the first turn.
</ParamField>

<ParamField path="model" type="string">
  LLM model name (e.g. `"gpt-5.2"`, `"gemini-3-flash-preview"`, `"claude-opus-4-6"`). Defaults to server default (typically `claude-sonnet-4-5`).
</ParamField>

<ParamField path="provider" type="string">
  Force a specific provider (`"anthropic"`, `"openai"`, `"gemini"`). Auto-detected from model if omitted.
</ParamField>

<Accordion title="All optional parameters">
<ParamField path="system_prompt" type="string">
  Override the default system prompt.
</ParamField>

<ParamField path="max_tokens" type="number">
  Maximum output tokens for the LLM response.
</ParamField>

<ParamField path="output_schema" type="Record<string, unknown>">
  JSON Schema for structured output extraction.
</ParamField>

<ParamField path="structured_output_retries" type="number" default="2">
  Max retries for structured output validation.
</ParamField>

<ParamField path="hooks_override" type="Record<string, unknown>">
  Run-scoped hook overrides.
</ParamField>

<ParamField path="enable_builtins" type="boolean" default="false">
  Enable built-in tools (task management, etc.).
</ParamField>

<ParamField path="enable_shell" type="boolean" default="false">
  Enable the shell tool (requires `enable_builtins`).
</ParamField>

<ParamField path="enable_subagents" type="boolean" default="false">
  Enable sub-agent tools (fork, spawn).
</ParamField>

<ParamField path="enable_memory" type="boolean" default="false">
  Enable semantic memory (memory_search tool + compaction indexing).
</ParamField>

<ParamField path="host_mode" type="boolean" default="false">
  Run in host mode for inter-agent comms.
</ParamField>

<ParamField path="comms_name" type="string">
  Agent name for comms (required when `host_mode` is `true`).
</ParamField>

<ParamField path="provider_params" type="Record<string, unknown>">
  Provider-specific parameters (e.g. thinking config).
</ParamField>
</Accordion>

### startTurn(sessionId, prompt)

```typescript
async startTurn(sessionId: string, prompt: string): Promise<WireRunResult>
```

Starts a new turn on an existing session. Returns a `WireRunResult`.

<ParamField path="sessionId" type="string" required>
  UUID of an existing session.
</ParamField>

<ParamField path="prompt" type="string" required>
  The user prompt for this turn.
</ParamField>

### interrupt(sessionId)

```typescript
async interrupt(sessionId: string): Promise<void>
```

Cancels an in-flight turn on the specified session. No-op if the session is idle.

### listSessions()

```typescript
async listSessions(): Promise<unknown[]>
```

Returns an array of session info objects (each containing `session_id` and `state`).

### readSession(sessionId)

```typescript
async readSession(sessionId: string): Promise<Record<string, unknown>>
```

Returns the current state of a session (contains `session_id` and `state`).

### archiveSession(sessionId)

```typescript
async archiveSession(sessionId: string): Promise<void>
```

Removes a session from the runtime. The session will no longer appear in `listSessions()`.

### getCapabilities()

```typescript
async getCapabilities(): Promise<CapabilitiesResponse>
```

Returns the cached capabilities response. If capabilities were not yet fetched (e.g. `connect()` was not called), fetches them from the server.

### hasCapability(capabilityId)

```typescript
hasCapability(capabilityId: string): boolean
```

Returns `true` if the given capability is `"Available"` in the runtime.

<Accordion title="Known capability IDs">
| Capability ID | Description |
|---------------|-------------|
| `"sessions"` | Session lifecycle (create/turn/list/read/archive) |
| `"streaming"` | Real-time event streaming |
| `"structured_output"` | JSON schema-based structured output extraction |
| `"hooks"` | Lifecycle hooks |
| `"builtins"` | Built-in tools |
| `"shell"` | Shell tool |
| `"comms"` | Inter-agent communication |
| `"sub_agents"` | Sub-agent tools (fork, spawn) |
| `"memory_store"` | Semantic memory |
| `"session_store"` | Session persistence |
| `"session_compaction"` | Context compaction |
| `"skills"` | Skill loading and invocation |
</Accordion>

### requireCapability(capabilityId)

```typescript
requireCapability(capabilityId: string): void
```

Throws `MeerkatError` with code `"CAPABILITY_UNAVAILABLE"` if the capability is not available.

### Config management

```typescript
// Read the current config.
const config = await client.getConfig();

// Replace the entire config.
await client.setConfig({ ...config, max_tokens: 4096 });

// Or merge-patch specific fields.
const updated = await client.patchConfig({ max_tokens: 8192 });
console.log(updated.max_tokens);  // 8192
```

| Method | Maps to | Returns |
|--------|---------|---------|
| `getConfig()` | `config/get` | `Record<string, unknown>` |
| `setConfig(config)` | `config/set` | `void` |
| `patchConfig(patch)` | `config/patch` | `Record<string, unknown>` (updated config) |

---

## Wire types

<Accordion title="WireRunResult">
Returned by `createSession()` and `startTurn()`.

```typescript
interface WireRunResult {
  session_id: string;
  text: string;
  turns: number;
  tool_calls: number;
  usage: WireUsage;
  structured_output?: unknown;
  schema_warnings?: Array<{
    provider: string;
    path: string;
    message: string;
  }>;
}
```
</Accordion>

<Accordion title="WireUsage">
Token usage statistics.

```typescript
interface WireUsage {
  input_tokens: number;
  output_tokens: number;
  total_tokens: number;
  cache_creation_tokens?: number;
  cache_read_tokens?: number;
}
```
</Accordion>

<Accordion title="WireEvent">
Event emitted as a JSON-RPC notification during a turn.

```typescript
interface WireEvent {
  session_id: string;
  sequence: number;
  event: Record<string, unknown>;
  contract_version: string;
}
```
</Accordion>

<Accordion title="CapabilitiesResponse and CapabilityEntry">
```typescript
interface CapabilitiesResponse {
  contract_version: string;
  capabilities: CapabilityEntry[];
}

interface CapabilityEntry {
  id: string;
  description: string;
  status: string;  // "Available", "DisabledByPolicy", "NotCompiled", etc.
}
```
</Accordion>

---

## CapabilityChecker

Standalone helper for checking runtime capabilities. Useful when you want to gate entire code paths based on what the server supports.

```typescript
import { MeerkatClient, CapabilityChecker } from "@meerkat/sdk";

const client = new MeerkatClient();
await client.connect();

const caps = await client.getCapabilities();
const checker = new CapabilityChecker(caps);

// Check if a capability is available.
if (checker.has("comms")) {
  console.log("Comms is available");
}

// Throw if a capability is missing.
checker.require("skills");  // throws CapabilityUnavailableError if unavailable

// List all available capability IDs.
console.log(checker.available);  // ["sessions", "streaming", ...]
```

| Method | Signature | Description |
|--------|-----------|-------------|
| `has` | `has(capabilityId: string): boolean` | Returns `true` if the capability status is `"Available"`. |
| `require` | `require(capabilityId: string): void` | Throws `CapabilityUnavailableError` if the capability is not available. |
| `available` | `get available(): string[]` | Getter that returns all capability IDs with status `"Available"`. |

---

## SkillHelper

Convenience wrapper for invoking Meerkat skills. Skills are loaded by the agent from filesystem and embedded sources. To invoke a skill, include its reference (e.g. `/shell-patterns`) in the user prompt.

```typescript
import { MeerkatClient, SkillHelper } from "@meerkat/sdk";

const client = new MeerkatClient();
await client.connect();

const helper = new SkillHelper(client);

// Check if skills are available in this runtime.
if (helper.isAvailable()) {
  // Invoke a skill in an existing session.
  const result = await helper.invoke(
    sessionId,
    "/shell-patterns",
    "How do I run a background job?",
  );
  console.log(result.text);
}

// Or create a new session and invoke a skill in one call.
const result = await helper.invokeNewSession(
  "/code-review",
  "Review this function for performance issues",
  "claude-opus-4-6",  // optional model override
);
```

| Method | Signature | Description |
|--------|-----------|-------------|
| `isAvailable` | `isAvailable(): boolean` | Returns `true` if the `"skills"` capability is available. |
| `requireSkills` | `requireSkills(): void` | Throws `CapabilityUnavailableError` if skills are not available. |
| `invoke` | `invoke(sessionId: string, skillReference: string, prompt: string): Promise<WireRunResult>` | Invokes a skill in an existing session. Prepends the skill reference to the prompt and calls `startTurn`. |
| `invokeNewSession` | `invokeNewSession(skillReference: string, prompt: string, model?: string): Promise<WireRunResult>` | Creates a new session and invokes a skill in the first turn. |

---

## EventStream

Async iterator that yields `WireEvent` objects from JSON-RPC notifications emitted by `rkat rpc` during a turn. Filters out response messages (which have an `id` field) and only yields notification payloads.

```typescript
import { createInterface } from "node:readline";
import { EventStream } from "@meerkat/sdk";
import type { Interface } from "node:readline";

// The EventStream wraps a readline interface attached to rkat's stdout.
const rl: Interface = createInterface({ input: process.stdin });
const stream = new EventStream(rl);

for await (const event of stream) {
  console.log(event.session_id, event.sequence, event.event);
}
```

<Note>
The `EventStream` class implements `AsyncIterable<WireEvent>`. It buffers events internally and resolves waiting consumers as events arrive. When the underlying readline interface closes, the iterator completes.

`MeerkatClient` handles the JSON-RPC response/notification multiplexing internally. `EventStream` is a lower-level primitive for advanced use cases where you manage the `rkat rpc` subprocess yourself.
</Note>

---

## Error handling

The SDK provides a hierarchy of error classes, all extending the base `MeerkatError`.

| Class | Description |
|-------|-------------|
| `MeerkatError` | Base error. Properties: `code` (string), `details` (unknown), `capabilityHint` (object). |
| `CapabilityUnavailableError` | Thrown when a required capability is not available. |
| `SessionNotFoundError` | Thrown when a session ID does not exist. |
| `SkillNotFoundError` | Thrown when a referenced skill cannot be found. |

<Accordion title="MeerkatError class definition">
```typescript
class MeerkatError extends Error {
  readonly code: string;
  readonly details?: unknown;
  readonly capabilityHint?: {
    capability_id: string;
    message: string;
  };

  constructor(
    code: string,
    message: string,
    details?: unknown,
    capabilityHint?: { capability_id: string; message: string },
  );
}
```
</Accordion>

### Error handling example

```typescript
import {
  MeerkatClient,
  MeerkatError,
  CapabilityUnavailableError,
} from "@meerkat/sdk";

const client = new MeerkatClient();

try {
  await client.connect();
  const result = await client.createSession({ prompt: "Hello" });
  console.log(result.text);
} catch (err) {
  if (err instanceof CapabilityUnavailableError) {
    console.error("Missing capability:", err.message);
    if (err.capabilityHint) {
      console.error("Hint:", err.capabilityHint.message);
    }
  } else if (err instanceof MeerkatError) {
    console.error(`Meerkat error [${err.code}]: ${err.message}`);
  } else {
    throw err;
  }
} finally {
  await client.close();
}
```

---

## Version compatibility

The SDK exports `CONTRACT_VERSION` (currently `"0.1.0"`). During `connect()`, the SDK checks that the server's contract version is compatible:

- While the major version is `0`, minor versions must match exactly (e.g. SDK `0.1.x` requires server `0.1.x`).
- Once `1.0.0` is reached, major versions must match (standard semver).

```typescript
import { CONTRACT_VERSION } from "@meerkat/sdk";
console.log(CONTRACT_VERSION);  // "0.1.0"
```

If the versions are incompatible, `connect()` throws a `MeerkatError` with code `"VERSION_MISMATCH"`.

---

## Examples

<Accordion title="Structured output">
```typescript
const client = new MeerkatClient();
await client.connect();

const result = await client.createSession({
  prompt: "List three European capitals",
  output_schema: {
    type: "object",
    properties: {
      capitals: {
        type: "array",
        items: { type: "string" },
      },
    },
    required: ["capitals"],
  },
  structured_output_retries: 3,
});

// Parsed structured output (matches the schema).
console.log(result.structured_output);
// { capitals: ["Paris", "Berlin", "Madrid"] }

// Schema warnings from provider-specific validation issues.
if (result.schema_warnings) {
  for (const w of result.schema_warnings) {
    console.warn(`[${w.provider}] ${w.path}: ${w.message}`);
  }
}

await client.close();
```
</Accordion>

<Accordion title="Multi-turn conversation">
```typescript
const client = new MeerkatClient();
await client.connect();

// Create session with first turn.
const session = await client.createSession({
  prompt: "My name is Alice.",
  model: "claude-sonnet-4-5",
});

// Follow-up turns reuse the session_id.
const turn2 = await client.startTurn(session.session_id, "What is my name?");
console.log(turn2.text);  // Should mention "Alice"

// Check session state.
const state = await client.readSession(session.session_id);
console.log(state);

// List all active sessions.
const sessions = await client.listSessions();
console.log(`Active sessions: ${sessions.length}`);

// Clean up.
await client.archiveSession(session.session_id);
await client.close();
```
</Accordion>

---

## See also

- [Rust SDK reference](/SDK) - Rust library API reference
- [Python SDK](/sdks/python) - Python SDK reference
- [RPC reference](/surfaces/rpc) - JSON-RPC protocol specification
- [Configuration](/configuration) - Configuration file reference
